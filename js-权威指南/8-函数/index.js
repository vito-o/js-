/**
 * 函数值这样的一段js代码，它只定义一次，但可能被执行或调用任意次。你可能已经从诸如子例程(subroutine)
 * 或者过程(procedure)这些名字里对函数的概念有所了解。js函数是参数化的：函数的定义会包括一个
 * 称为形参（parameter）的标识符列表,这些参数在函数体中像局部变量一样工作。函数调用会为形参提供
 * 实参的值。函数使用他们实参的值来计算返回值，成为该函数调用表达式的值。除了实参之外，每次调用
 * 换回拥有另一个值--本次调用的上下文--这就是this关键字的值。
 * 
 * 如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。当通过这个对象来调用函数时，
 * 该对象就是此次调用的上下文（context），也就是该函数的this的值。用于初始化一个新创建的对象的
 * 函数称为构造函数(constructor)
 * 
 * 在js里，函数即对象，程序可以随意操作他们。比如js可以把函数赋值为变量，或者作为参数传递给其他函数
 * 因为函数就是对象，所以可以给他们设置属性，甚至调用他们的方法。
 * 
 * js的函数可以嵌套在其他函数中定义，这样他们就可以访问他们被定义时所处的作用于中的任何变量。
 * 这以为着js函数构成了一个闭包（closure），它为js带来了非常强劲的编程能力，
 * 
 * 8.1 函数定义
 * 
 * 函数使用function关键字来定义，它可以用在函数定义表达式或者函数声明语句里。这两种形式中，函数
 * 定义都从function关键字开始，气候跟随这些组成部分：
 * 。函数名称标识符。函数名称是函数声明语句必须的部分。它的用途就像变量的名字，新定义的函数对象
 * 会赋值给这个变量。对函数定义表达式来说，这个名字是可选的：如果存在，该名字只存在于函数体中
 * 并指代函数对象本身。
 * 。一堆圆括号，轻重包含由0个或者多个用逗号隔开的标识否组成的列表。这些标识符是函数的参数名称
 * 他们就像函数体中的局部变量。
 * 。一堆花括号，其中包含0条或多条js语句。这些语句构成了函数体：一旦调用函数，就会执行这些语句
 * 
 * 8-1分别展示了函数语句和表达式两种方式的函数定义。注意，以表达式来定义函数只适用于它作为一个
 * 大的表达式的一部分，比如在赋值和调用过程中定义函数：
 * 
 * function printprops(o){
 *    for(var p in o)
 *      console.log(p + ": " + o[p] + "\n");
 * }
 * 
 * function distance(x1, y1, x2, y2){
 *    var dx = x2 - x1;
 *    var dy = y2 - y1
 *    return Math.sqrt(dx*dx + dy*dy)
 * }
 * 
 * function factorial(x){
 *    if(x <= 1) return 1;
 *    return x * factorial(x - 1)
 * }
 * 
 * //函数表达式
 * var square = function(x){return x * x}
 * 
 * var f = function fact(x){if(x <= 1) return 1; else return x*fact(x - 1)}
 * 
 * data.sort(function(a, b){return a - b})
 * 
 * var tensquared = (function(x){return x*x}(10))
 * 
 * 注意：以表达式方式定义的函数，函数的名称是可选的。一条函数声明语句实际上声明了一个变量，并
 * 把一个函数对象赋值给他。相对而言，定义函数表达式时并没有声明一个变量。函数可以命名，就像上
 * 面的阶乘函数，它需要一个名称来指代自己。如果一个函数定义表达式包含名称，函数的局部作用于
 * 将会包含一个绑定到函数对象的函数名称。实际上，函数的名称将成为函数内部的一个局部变量。通常
 * 而言，以表达式方式定义函数时都不需要名称，这会让定义他们的代码更为紧凑。函数定义表达式特别
 * 适合用来定义那些只会用到一次的函数，比如上面展示的最后两个例子。
 * 
 * 如5.3.2所述，函数声明语句‘被提前’到外部脚本或外部函数作用于的顶部，所以以这种方式声明的函数
 * 可以被在他定义之前出现的代码所调用，不过，以表达式定义的函数就另当别论，为了调用一个函数，必须
 * 要能引用它，而要使用一个以表达式方式定义的函数之前，必须把它复制给一个变量。变量的声明提前了
 * 但给变量赋值是不会提前的，所以，以表达式方式定义的函数在定义之前无法调用
 * 
 * 请注意，在8-1中的大多数函数包含一个return语句。return语句导致函数停止执行，并返回它的表达式
 * （如果有的话）的值给调用者。如果return语句没有一个与之相关的表达式，则它返回undefined值，如果
 * 一个函数不包含return语句，那它就只执行函数体中的每条语句，并返回undefined值给调用者。
 * 
 * 例8-1中的大多数函数都是用来计算出一个值得，他们使用return把值返回给调用者。而printprops()
 * 函数的不同之处在于，它的任务是输出对象各属性的名称和值。没有必要返回值，该函数不包含return
 * 语句。printprops()函数的返回值始终是undefined(没有返回值的函数有时候称为过程)
 * 
 * 嵌套函数
 * 
 * 在js里，函数可以嵌套在其他函数里。例如：
 * 
 * function hypotenuse(a, b){
 *    function square(x){return x*x}
 *    return Mah.sqrt(square(a) + square(b))
 * }
 * 
 * 嵌套函数的有趣支撑处在于他的遍历作用于规则：他们可以发放完嵌套他们（或多重嵌套）的函数的参数
 * 和变量。例如，在上面的代码里，内部函数square()可以读写外部函数hypotenuse()函数的参数a和b。
 * 这些作用于规则对内嵌函数非常重要。
 * 
 * 5.3.2节曾提到，函数声明语句并非真正的语句，ECMAScript规范只是允许他们作为顶级语句。他们可以出现在全局
 * 代码里，或者内嵌在其他函数中，但他们不能出现在循环、条件判断，或者try/cache/finallyyiji with
 * 语句中。注意，此限制仅适用于语句声明形式定义的函数。函数定义表达式可以出现在js代码的任何地方
 * 
 * 8.2 函数调用
 * 
 * 构成函数主体的js代码在定义之时并不会执行，只有调用该函数时，他们才会执行。
 * 有4中方式来调用js函数
 * .作为函数
 * .作为方法
 * .作为构造函数
 * .通过他们的call()和apply()方法简介调用
 * 
 * 8.2.1 函数调用
 * 
 * 使用调用表达式可以进行普通的函数调用也可以进行方法调用。一个调用表达式由多个函数表达式组成，
 * 每个函数表达式都是由一个函数对象和左括号、参数猎豹和有括号组成，参数猎豹是由逗号分隔的零个
 * 或多个参数表达式组成。如果函数表达式时一个属性访问表达式，即该函数是一个对象的属性或数组中
 * 的一个元素，那么它就是一个方法调用表达式。下面将会解释这种情况。下面的代码展示了一些普通的
 * 函数调用表达式：
 * printprops({x:1})
 * var total = distance(0, 0, 2, 1) + distance(2,1,3,5)
 * var probabilitty = factorial(5) / factorial(13)
 * 
 * 在一个调用中，每个参数表达式（圆括号之间的部分）都会计算出一个值，计算的结果作为参数传递给
 * 另外一个函数。这些值作为实参传递给声明函数时定义的形参。在函数体中存在一个形参的引用，指向当前
 * 传出的实参列表，通过它可以获得参数的值
 * 
 * 对于普通的函数调用，函数的返回值称为调用表达式的值。如果该函数返回是因为解释器到达结尾，返回
 * 值就是undefined.如果函数返回是因为解释器执行到一条return 语句，返回值就是return之后的表达式
 * 的值，如果return语句没有值，则返回undefined
 * 
 * 根据ECMAScript3和非严格的EMCAScript5对函数调用的规定，调用上下文是全局对象，。而在严格模式下
 * 调用上下文则是undefined
 * 
 * 以函数形式调用的函数通常不适用this关键字。不过，this可以用来判断当前是否都是严格模式。
 * var strict = (fuction(){return !this}())
 * 
 * 8.2.2方法调用
 * 
 * 一个方法无非是个保存在一个对象的属性里的js函数。如果有一个函数f和一个对象o，则可以用下面的代码给
 * o定义一个名为m()的方法：
 * o.m = f;
 * 给对象o定义了方法m()，调用它时就像这样:
 * o.m()
 * 或者，如果m()需要在两个参数，调用起来则像这样：
 * o.m(x, y)
 * 上面的代码是一个调用表达式：它包括一个函数表达式o.m，以及两个实参表达式x和y，函数表达式本身就是
 * 一个属性访问表达式，这意味这该函数被当做一个方法。而不是作为一个普通函数来调用。
 * 
 * 对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个
 * 重要的区别，即：调用上下文。属性访问表达式由两部分组成：一个对象（本例中的o）和属性名称（m）。这
 * 像这样的方法调用表达式里，对象o成为调用上下文，海曙提可以使用关键字this引用该对象。
 * var calculator = {
 *    operand1:1,
 *    operand2:1,
 *    add:function(){
 *      this.result = this.operand1 + this.operand2;
 *    }
 * }
 * 
 * calculator.add()
 * calculator.result
 * 
 * 大多数方法调用使用点符号来访问属性，使用方括号（的属性访问表达式）也可以进行属性访问操作。
 * o['m'](x, y)
 * a[0](z)
 * 
 * 方法调用可能包括更复杂的属性访问表达式
 * customer.surname.toUpperCase()
 * f().m()
 * 
 * 方法和this关键字是面向对象编程的范例的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参--
 * 这个实参是一个对象，方法调用的母体就是这个对象。通常来讲，基于那个对象的方法可以执行多种操作，
 * 方法调用的语法已经很清晰地表明了函数将基于一个对象进行操作，比较下面两行代码
 * rect.setSize(width, height)
 * setRectSize(rect, width, height)
 * 
 * 我们假设这两行代码的功能完全一样，他们都作用于一个假定的对象rect。可以看出，第一行的方法调用语法
 * 非常清晰地表明这个函数执行的载体是rect对象，函数中的所有操作都将基于这个对象。
 * 
 * 需要注意的是，this是一个关键字，不是变量也不是属性名。js的语法不允许给this赋值。
 * 和变量不同，关键字this没有作用于的限制，嵌套的函数不会从调用它的函数中继承this。如果嵌套函数作为
 * 方法调用，其this的值指向调用它的对象。如果嵌套函数作为函数调用，其this值不是全局对象（非严格模式下）
 * 就是undefined(严格模式下)。很多人误以为调用嵌套函数时this会指向调用外层函数的上下文。如果你想访问
 * 这个挖我不函数的this值，需要将this的值保存在一个变量里，这个变量和内部函数都同在一个作用于中。通常使用
 * 变量self来保存this，比如：
 * var o = {
 *    m:function(){
 *      var self = this;
 *      console.log(this === o)
 *      f();
 * 
 *      function f(){
 *        console.log(this === o)
 *        console.log(self === o)
 *      }
 *    }
 * }
 * 
 * o.m()
 * 
 * 
 */


 function test(cb){
   console.log(this)
   cb()
 }

function eat(){
  console.log(this)
}

 test(eat);