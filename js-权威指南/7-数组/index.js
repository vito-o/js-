/**
 * 数组是值得有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。js数组
 * 是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至
 * 也可能是对象或其他数组，这允许创建复杂的数据结构，如对象的数组和数组的数组。js数组的索引是基于零
 * 的32位数值：第一个元素的索引为0，最大可能的索引为4 294 967 294 （2^32 - 2），数组最大能容纳
 * 4294969295个元素。js数组是动态的：根据需要他们会增长或缩减并且在创建数组时无需声明一个固定的大小
 * 或者在数组大小变化时无需重新分配空间。js数组可能是稀疏的：数组元素的索引不一定要连续的，他们之间
 * 可以有空缺。每个js数组有一个length属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，
 * length比所有元素的索引要大
 * 
 * js数组是js对象的特殊形式，数组索引时间上和碰巧是整数的属性名差不多。我们将在本章的其他地方更多地
 * 讨论特殊化的数组。通常，数组的时间是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象
 * 属性要快很多
 * 
 * 数组继承自Array.prototype中的属性，它定义了一套丰富的数组操作方法，大多数这些方法是通用的，这
 * 意味着他们不仅对真正的数组有效，而且对'类数组对象'同样有效
 * 
 * 7.1创建数组
 * 
 * 使用数组直接量是创建数组最简单的方法，在方括号中将数组用逗号隔开即可。
 * 例如：
 * var empty = []                 //没有元素的数组
 * var primes = [2, 3, 5, 7, 11]  //有5个数值的数组
 * var misc = [1.1, true, 'a', ]  //有三个不同类型的元素和结尾的逗号
 * 
 * 数组直接量中的值不一定要是常量；他们可以是任意的表达式
 * 
 * var base = 1024
 * var table = [base, base+1, base+2, base+3]
 * 
 * 它可以包含对象直接量或其他数组直接量：
 * var b = [[1, {x:1, y:2}], [2, {x:3, y:4}]]
 * 
 * 如果省略数组直接量中的某个值，省略的元素将被赋予undefined值
 * 
 * var count = [1, , 3] //数组有3个元素，中间的那个元素值为undefined
 * var undefs = [, ,]   //数组有2个元素，都是undefined
 * 
 * 数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个元素
 * 调用构造函数Array()是创建数组的另一种方法。可以用三种方式调用构造函数。
 * 
 * 调用时没有参数
 * var a = new Array()
 * 该方法创建一个没有任何元素的空数组，等同于数组直接量[]。
 * 
 * 调用时有一个数组参数，它指定长度
 * var a = new Array(10)
 * 该技术创建指定长度的数组。当预先知道所需元素的个数时，这种形式的Array()构造函数可以用来分配一个
 * 数组看空间。注意，数组中没有存储值，甚至数组的索引属性'0'、'1'等还未定义。
 * 显式指定两个或者多个数组元素或者数组的一个非数值元素
 * var a = new Array(5, 4, 3, 2, 1, 'testing, testing')
 * 
 * 以这种形式，构造函数的参数将会成为新数组的元素。使用数组字面量比这样使用Array()构造函数要简单多了。
 * 
 * 7.2数组元素的读和写
 * 
 * 使用[]操作符来访问数组中的一个元素。数组的引用位于方括号的左边，方括号中是一个返回非负整数值的任意
 * 表达式。使用该语法既可以读又可以写数组的一个元素。因此，如下代码都是合法的js语句
 * 
 * var a = ['world']    //从一个元素的数组开始
 * var value = a[0]     //读第0个元素
 * a[1] = 3.14          //写第一个元素
 * i= 2
 * a[i] = 3             //写第2个元素
 * a[i +1] = 'hello'    //写第三个元素
 * a[a[i]] = a[0]       //读第0个和第二个元素，写第3个元素
 * 
 * 请记住，数组是对象的特殊新式。使用方括号访问数组元素就像用方括号访问对象的属性一样。js将指定的
 * 数组索引转换成字符串----索引值1变成'1'----然后将其作为属性名来使用。关于索引值从数字转换为字符串没
 * 什么特别之处；对常规对象也可以这么做；
 * 
 * o = {}           //创建一个普通的对象
 * o[1] = 'one'     //用一个整数来索引它
 * 
 * 数组的特别之处在于，当使用小于2^32的非负数作为属性名时数组会自动维护其length属性值。如上，创建
 * 仅有一个元素的数组。然后在索引1、2和3处分别进行赋值。当我们这么做时数组的length属性值变为：
 * 
 * a.length         // => 4
 * 
 * 清晰区分分数数组的所有和对象的属性名时非常有用的。所有的索引都是属性名，但只有在0~2^32-2之间的
 * 整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引
 * 数组的特殊行为就是将根据需要更新他们的length属性值。
 * 
 * 注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然
 * 名字不是非负数，他就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负数的字符串
 * 它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相同时情况也是一样的
 * 
 * a[-1.23] = true    //浙江创建一个名为'-1.23'的属性
 * a['1000'] = 0      //这是数组的第1001个元素
 * a[1.000]           //和a[1]相等
 * 
 * 事实上数组索引仅仅是对象属性名的一种特殊类型，这以为这js数组没有‘越界’错误带概念。当试图查询任何
 * 对象中不存在的属性时，不会报错，只会得到undefined值。类似于对象，对于对象同样存在这种情况。
 * 
 * 既然数组是对象，那么他们可以从原型中继承元素。在ECMAScript5中，数组可以定义元素的getter和setter
 * 方法，你应该期望它使用非优化代码路径：访问这种数组的元素的时间会与常规对象属性的查找时间相近。
 * 
 * 7.3 稀疏数组
 * 
 * 稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性代表数组中元素的个数。如果数组是
 * 稀疏的，length属性值大于元素的个数。可以用Array()构造函数或简单地指定数组的索引值大于当前的数组
 * 长度来创建稀疏数组。
 * 
 * a = new Array(5)   //数组没有元素， 但是a.length是5
 * a = []             //创建一个空数组，length = 0
 * a[1000] = 0        //赋值添加一个元素，但是设置length为1001
 * 
 * 后面会看到你也可以用delete操作符来产生稀疏数组。
 * 
 * 足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规
 * 对象属性的查找时间一样长。
 * 
 * 注意。当在数组直接量中省略值时不会创建稀疏数组。省略的元素在数组中是存在的，其值为undefined。
 * 这和数组元素根本不存在是有一些微妙的区别的。可以用in操作符检测两者之间的区别
 * 
 * var a1 = [,,,]   //数组是[undefined, undefined, undefined,]    ---- chrome 测试与结果不符
 * var a2 = new Array(3)  //该数组根本没有元素
 * 0 in a1    //true  a1在索引0处有一个元素 ---- chrome 测试与结果不符
 * 0 in a2    //false a2在索引0处没有元素
 * 
 * 需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如[1,,3]），这时所得到的数组也是稀疏
 * 数组，省略掉的值是不存在的
 * 
 * var a1 = [,]           //此数组没有元素，长度是1
 * var a2 = [undefined]   //此数组包含一个值为undefined的元素
 * 
 * 0 in a1        //false a1在索引0处没有元素
 * 0 in a2        //true  a2在索引0处有一个值为undefined的元素
 * 
 * 
 * 在一些旧版本的实现中，在存在连续逗号的情况下，插入undefined值得操作则与此不同，在这些实现中，
 * [1,,3]和[1,undefined,3]是一模一样的。
 * 了解稀疏数组是了解js数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数js数组不是稀疏数组
 * 并且，如果你确实碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样来对待他们，只不过他们包含一些
 * undefined值。
 * 
 * 7.4 数组长度
 * 
 * 每个数组有一个length属性，就是这个属性使其区别于常规的js对象。针对稠密（也就是非稀疏）数组，length
 * 熟悉值代表数组中元素的个数。其值比数组中最大的索引大1：
 * [].length                //0：数组没有元素
 * ['a', 'b', 'c'].length   //3：最大的索引为2，length为3
 * 
 * 当数组是稀疏的时，length属性值大于元素的个数。而且关于此我们可以说的一切也就是数组长度保证大于
 * 每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于
 * 它的长度。为了维持此规则不变化，数组有两个特殊的行为。第一个如同上面的描述：如果为一个数组元素
 * 赋值他的索引i大于或等于现有数组的长度时，length属性的值将设置为i+1
 * 
 * 第二个特殊的行为就是设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或
 * 等于n的元素将从中删除
 * 
 * a = [1,2,3,4,5]      //从5个元素的数组开始
 * a.length = 3;        //现在a为[1,2,3]
 * a.legnth = 0;        //删除所有的元素。a为[]
 * a.legnth = 5;        //长度为5，但是没有元素，就像new Array(5)
 * 
 * 还可以将数组的length属性值设置为大于其当前的长度。实际上这不会向数组中添加新元素，它只是在数组
 * 尾部创建一个空的区域。
 * 
 * 在ECMAScript5中，可以用Object.defineProperty()让数组的length属性变成只读的
 * a = [1, 2, 3]                                          //从3个元素的数组开始
 * Object.defineProperty(a, 'length', {writable:false})   //上length属性只读
 * a.length = 0                                           //a不会改变
 * 
 * 类似地，如果让一个数组元素不能配置，就不能删除它。如果不能删除它，length属性不能设置为小于不可
 * 配置元素的索引值。
 * 
 * 7.5 数组元素的添加和删除
 * 
 * 我们已经见过添加数组元素最简单的方法：为新索引赋值
 * a = []       //开始是一个空数组
 * a[0] = 'zero'//然后像其中添加元素
 * a[1] = 'one'
 * 
 * 也可以使用push()方法在数组末尾则加一个或多个元素
 * a = []                 //开始是一个空数组
 * a.push('zero')         //在末尾添加一个元素。a = ['zero']
 * a.push('one', 'two')   //再添加两个元素。a = ['zero', 'one', 'two']
 * 
 * 在数组尾部压入一个元素与给定数组a[a.length]赋值是一样的。可以使用unshift()方法在数组的首部插入
 * 一个元素，并且将其他元素依次移到更高的索引处。
 * 
 * 可以像删除对象属性一样使用delete运算符来删除数组元素
 * a = [1,2,3]
 * delete a[1]    //a在索引1的位置不再有元素
 * 1 in a         //false 数组索引1并未在数组中定义
 * a.length       //3 delete操作并不影响数组长度
 * 
 * 删除数组元素与为其赋undefined值时类似的（但有一些微妙的区别）。注意，对一个数组元素使用delete
 * 不会修改数组的length属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除
 * 一个元素，他就变成稀疏数组。
 * 上面我们看到，也可以简单地设置length属性为一个新的期望长度来删除数组尾部的元素。数组由pop()方法
 * （它和push()一起使用），后者一次使减少长度1并返回被删除元素的值。患有一个shift()方法（它和unshift()
 * 一起使用），从数组都不删除一个元素。和delete不同的是shift()方法将所有元素下移到比当前索引更低
 * 1的地方。
 * 最后，splice()是一个通用的方法来插入、删除或替换数组元素。它会更具需要修改length属性并移动元素
 * 到更高或较低的索引处
 * 
 * 7.6数组遍历
 * 
 * 使用for循环是遍历数组元素最常见的方法：
 * 
 */
