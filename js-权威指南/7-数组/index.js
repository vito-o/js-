/**
 * 数组是值得有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。js数组
 * 是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至
 * 也可能是对象或其他数组，这允许创建复杂的数据结构，如对象的数组和数组的数组。js数组的索引是基于零
 * 的32位数值：第一个元素的索引为0，最大可能的索引为4 294 967 294 （2^32 - 2），数组最大能容纳
 * 4294969295个元素。js数组是动态的：根据需要他们会增长或缩减并且在创建数组时无需声明一个固定的大小
 * 或者在数组大小变化时无需重新分配空间。js数组可能是稀疏的：数组元素的索引不一定要连续的，他们之间
 * 可以有空缺。每个js数组有一个length属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，
 * length比所有元素的索引要大
 * 
 * js数组是js对象的特殊形式，数组索引时间上和碰巧是整数的属性名差不多。我们将在本章的其他地方更多地
 * 讨论特殊化的数组。通常，数组的时间是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象
 * 属性要快很多
 * 
 * 数组继承自Array.prototype中的属性，它定义了一套丰富的数组操作方法，大多数这些方法是通用的，这
 * 意味着他们不仅对真正的数组有效，而且对'类数组对象'同样有效
 * 
 * 7.1创建数组
 * 
 * 使用数组直接量是创建数组最简单的方法，在方括号中将数组用逗号隔开即可。
 * 例如：
 * var empty = []                 //没有元素的数组
 * var primes = [2, 3, 5, 7, 11]  //有5个数值的数组
 * var misc = [1.1, true, 'a', ]  //有三个不同类型的元素和结尾的逗号
 * 
 * 数组直接量中的值不一定要是常量；他们可以是任意的表达式
 * 
 * var base = 1024
 * var table = [base, base+1, base+2, base+3]
 * 
 * 它可以包含对象直接量或其他数组直接量：
 * var b = [[1, {x:1, y:2}], [2, {x:3, y:4}]]
 * 
 * 如果省略数组直接量中的某个值，省略的元素将被赋予undefined值
 * 
 * var count = [1, , 3] //数组有3个元素，中间的那个元素值为undefined
 * var undefs = [, ,]   //数组有2个元素，都是undefined
 * 
 * 数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个元素
 * 调用构造函数Array()是创建数组的另一种方法。可以用三种方式调用构造函数。
 * 
 * 调用时没有参数
 * var a = new Array()
 * 该方法创建一个没有任何元素的空数组，等同于数组直接量[]。
 * 
 * 调用时有一个数组参数，它指定长度
 * var a = new Array(10)
 * 该技术创建指定长度的数组。当预先知道所需元素的个数时，这种形式的Array()构造函数可以用来分配一个
 * 数组看空间。注意，数组中没有存储值，甚至数组的索引属性'0'、'1'等还未定义。
 * 显式指定两个或者多个数组元素或者数组的一个非数值元素
 * var a = new Array(5, 4, 3, 2, 1, 'testing, testing')
 * 
 * 以这种形式，构造函数的参数将会成为新数组的元素。使用数组字面量比这样使用Array()构造函数要简单多了。
 * 
 * 7.2数组元素的读和写
 * 
 * 使用[]操作符来访问数组中的一个元素。数组的引用位于方括号的左边，方括号中是一个返回非负整数值的任意
 * 表达式。使用该语法既可以读又可以写数组的一个元素。因此，如下代码都是合法的js语句
 * 
 * var a = ['world']    //从一个元素的数组开始
 * var value = a[0]     //读第0个元素
 * a[1] = 3.14          //写第一个元素
 * i= 2
 * a[i] = 3             //写第2个元素
 * a[i +1] = 'hello'    //写第三个元素
 * a[a[i]] = a[0]       //读第0个和第二个元素，写第3个元素
 * 
 * 请记住，数组是对象的特殊新式。使用方括号访问数组元素就像用方括号访问对象的属性一样。js将指定的
 * 数组索引转换成字符串----索引值1变成'1'----然后将其作为属性名来使用。关于索引值从数字转换为字符串没
 * 什么特别之处；对常规对象也可以这么做；
 * 
 * o = {}           //创建一个普通的对象
 * o[1] = 'one'     //用一个整数来索引它
 * 
 * 数组的特别之处在于，当使用小于2^32的非负数作为属性名时数组会自动维护其length属性值。如上，创建
 * 仅有一个元素的数组。然后在索引1、2和3处分别进行赋值。当我们这么做时数组的length属性值变为：
 * 
 * a.length         // => 4
 * 
 * 清晰区分分数数组的所有和对象的属性名时非常有用的。所有的索引都是属性名，但只有在0~2^32-2之间的
 * 整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引
 * 数组的特殊行为就是将根据需要更新他们的length属性值。
 * 
 * 注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然
 * 名字不是非负数，他就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负数的字符串
 * 它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相同时情况也是一样的
 * 
 * a[-1.23] = true    //浙江创建一个名为'-1.23'的属性
 * a['1000'] = 0      //这是数组的第1001个元素
 * a[1.000]           //和a[1]相等
 * 
 * 事实上数组索引仅仅是对象属性名的一种特殊类型，这以为这js数组没有‘越界’错误带概念。当试图查询任何
 * 对象中不存在的属性时，不会报错，只会得到undefined值。类似于对象，对于对象同样存在这种情况。
 * 
 * 既然数组是对象，那么他们可以从原型中继承元素。在ECMAScript5中，数组可以定义元素的getter和setter
 * 方法，你应该期望它使用非优化代码路径：访问这种数组的元素的时间会与常规对象属性的查找时间相近。
 * 
 * 7.3 稀疏数组
 * 
 * 稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性代表数组中元素的个数。如果数组是
 * 稀疏的，length属性值大于元素的个数。可以用Array()构造函数或简单地指定数组的索引值大于当前的数组
 * 长度来创建稀疏数组。
 * 
 * a = new Array(5)   //数组没有元素， 但是a.length是5
 * a = []             //创建一个空数组，length = 0
 * a[1000] = 0        //赋值添加一个元素，但是设置length为1001
 * 
 * 后面会看到你也可以用delete操作符来产生稀疏数组。
 * 
 * 足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规
 * 对象属性的查找时间一样长。
 * 
 * 注意。当在数组直接量中省略值时不会创建稀疏数组。省略的元素在数组中是存在的，其值为undefined。
 * 这和数组元素根本不存在是有一些微妙的区别的。可以用in操作符检测两者之间的区别
 * 
 * var a1 = [,,,]   //数组是[undefined, undefined, undefined,]    ---- chrome 测试与结果不符
 * var a2 = new Array(3)  //该数组根本没有元素
 * 0 in a1    //true  a1在索引0处有一个元素 ---- chrome 测试与结果不符
 * 0 in a2    //false a2在索引0处没有元素
 * 
 */
