/**
 * 对象
 * 
 * 对象是js的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起
 * 可通过名字访问这些值。对象也可看作是属性的无序集合，每个属性都是一个名/值对。属性名
 * 是字符串，因此我们可以把对象看成是从字符串到值的映射。这种基本数据结构还有很多种叫法
 * 有些我们已然非常熟悉，比如‘散列’（hash）、‘散列表’（hashtable）、‘字典’（dictionary）
 * ‘关联数组’(associative array)。然而对象不仅仅是字符串到值得映射，除了可以保持自有
 * 的属性，js对象还可以总一个称为原型的对象继承属性。对象的方法通常是继承的属性。这种
 * 原型式继承（prototypal inheritance）是js的核心特征
 * 
 * js对象是动态的--可以新增属性也可以删除属性--但他们常用来模拟静态对象以及静态类型语言
 * 中的‘结构体’（struct）。有时他们也用做字符串的集合（忽略名值对中的值）。
 * 
 * 除了字符串、数字、true、false、null和undefined之外，js中的值都是对象。js中的值都是
 * 对象。尽管字符串、数字和布尔值不是对象，但他们的行为和不可变对象非常相似。
 * 
 * 3.7节已经降到，对象是可变的，我们通过引用而非值来操作对象。如果变量x是指向一个对象的
 * 引用，那么指向代码var y = x;变量y也是指向同一个对象的引用，而非这个对象的副本。通过
 * 变量y修改这个对象亦会对变量x造成影响。
 * 
 * 对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测
 * （test）和枚举（enumerate）它的属性。我们会在开始的几节讲述这些基础操作。后续的几节
 * 讲述高级主题，其中相当一部分内容来自于ECMAScript5
 * 
 * 属性包括名字和值。属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名
 * 的属性。值可以是任意js值，或者可以是一个getter或setter函数（或两者都有）。6.6节会有
 * 关于getter和setter函数的讲解。除了名字和值之外，每个属性还有一些与之相关的值，称为
 * “属性特性”（property attribute）
 * 。可写（writable attribute），表明是否可以设置该属性的值
 * 。可枚举（enumerable attribute），表明是否可以通过for/in循环返回该属性
 * 。可配置（configurable attribute），表明是否可以删除或修改该属性
 * 
 * 在ECMAScript5之前，通过代码给对象创建的所有属性都是可写的、可枚举的盒可配置的。在
 * ECMAScript5中则可以对这些特性加以配置。
 * 
 * 除了包含属性之外，每个对象还拥有三个相关的对象特性（object attribute）
 * 。对象的原型（prototype）指向另一个对象，本对象的属性继承自它的原型对象
 * 对象的类（class）是一个标识对象类型的字符串
 * 对象的扩展标记（extensible flag）指明了是否可以向该对象添加新属性
 * 
 * 最后，我们用下面这些术语来对三类js对象和两类属性做区分
 * 。内置对象（native object）是由ECMAScript规范定义的对象或类。例如，数组、函数、日期
 * 和正则表达式都是内置对象。
 * 。宿主对象（host object）是由js解释器所嵌入的宿主环境（比如web浏览器）定义的。客户端
 * js中标识网页结构的HTMLElement对象均值宿主对象。既然宿主环境定义的方法可以当成普通的
 * js函数对象，那么宿主对象也可以当成内置对象。
 * 。自定义对象（user-defined object）是由允许中的js代码创建的对象。
 * 。自有属性（own property）是直接在对象中定义的属性
 * 。继承属性（inherited property）实在对象的原型对象中定义的属性
 * 
 * 6.1 创建对象
 * 
 * 可以通过对象直接量、关键字new和Object.create()函数来创建对象
 * 
 * 6.1.1 对象直接量
 * 
 * 创建对象最简单的方式就是在js代码中使用对象直接量。对象直接量是由若干名/值对组成的映射
 * 表，名/值对中间用冒号分隔，名/值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以
 * 是js标识符也可以是字符串直接量（包括空字符串）。属性的值可以是任意类型的js表达式，表
 * 达式的值（可以是原始值也可以是对象值）就是这个属性的值
 * 
 *  var empty = {}     //没有任何属性的对象
    var point = {x:0, y:1}  //两个属性
    var point2 = {x:point.x, y:point.y+1}  //更复杂的值
    var book = {
        "main title": 'Javascript',    //属性名字里有空格，必须用字符串表示
        'sub-title': 'The Definitive Guide',   //属性名字里有连字符，必须用字符串表示
        "for": "all audiences",        //‘for’是保留字，因此必须用引号
        author:{                       //这个属性的值是一个对象
            firstname:"David",         //注意，这里的属性名没有引号
            surname:"Flanagan"
        }
    }
 * 
 *
 * 在ECMAScript 5（以及ECMAScript 3的一些实现）中，保留字可以用用作不带引号的属性名。
 * 然而对于ECMAScript3来说，使用保留字作为属性名必须使用引号引起来。在ECMAScript5中，
 * 对象直接量中的最后一个属性后的逗号将忽略，而在ECMSAScript3的大部分实现中也可以忽略
 * 这个逗号，单在IE中则报错
 * 
 * 对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象
 * 直接量的时候，也都会计算他的每个属性的值，也就是说，如果在一个重复调用的函数中的循环
 * 体内使用了对象直接量，他将创建很多新对象，并且每次创建的对象的属性值也有可能不同
 * 
 * 6.1.2 通过new创建对象
 * 
 * new运算符创建并初始化一个新对象。关键字new后跟随一个函数调用。这里的函数称作构造函数
 * （constructor），构造函数用以初始化一个新创建的对象。js语言核心中的原始类型都包含内置
 * 构造函数。例如：
 * 
 *  var o = new Object()    //创建一个空对象，和{}一样
    var a = new Array()     //创建一个空数组，和[]一样
    var d = new Date()      //创建一个表示当时时间的Date对象
    var i = new RegExp('js')//创建一个可以进行模式匹配的RegExp对象

 * 
 * 除了这些内置构造函数，用自定义构造函数来初始化新对象也是非常常见的
 * 
 * 6.1.3原型
 * 
 * 在讲述第三种对象创建技术之前，我们应当首先解释一下原型。每一个js对象（null除外）都和
 * 另一个对象相关联。‘另一个’对象就是我们熟知的原型，每一个对象都从原型继承属性
 * 
 * 所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过js代码Object.prototype获得
 * 对原型对象的引用。通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype
 * 属性的值。因此，同使用{}创建对象一样，通过new Array()创建的对象的原型就是Array.prototype
 * 通过new Date()创建的对象的原型就是Date.prototype。
 * 
 * 没有原型的对象为数不多，Object.prototype就是其中之一。它不继承任何属性。其他原型对象
 * 都是普通对象，普通对象都具有原型。所有的内置构造函数（以及大部分自定义的构造函数）都
 * 具有一个继承自Object.prototype的原型。例如，Date.prototype的属性继承自Object.prototype
 * 因此new Date()创建的Date对象的属性同事继承自Date.prototype和Object.prototype。这
 * 一系列连接的原型对象就是所谓的‘原型链’（prototype chain）
 * 
 * 6.1.4 Object.create()
 * 
 * ECMAScript 5定义了一个名为Object.create()的方法，它创建一个新对象，其中第一个参数是
 * 这个对象的原型。Object.create()提供第二个可选参数，用以对对象的属性进行进一步描述
 * 
 * Object.create()是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，
 * 只需传入所需的原型对象即可：
 * 
 * var o1 = Object.create({x:1, y:2})  //o1继承了属性x和y
 * 
 * 可以通过传入参数null来穿件一个没有原型的对象，但通过这种方式创建的对象不会继承任何东西
 * 甚至不包括基础方法，比如toString()，也就是说，它将不能和'+'运算符一起正常使用
 * 
 */




