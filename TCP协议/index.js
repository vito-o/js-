/**
 * TCP协议
 * 
 * TCP传输层的协议
 * 
 * 能不能说一下TCP和UDP的区别
 * 
 * 首先概况一下基本区别:
 * 
 * TCP是一个面向连接的\可靠的\基于字节流的传输协议
 * UDP是一个面向无连接的传输层协议
 * 
 * 具体分析,和udp相比,TCP有三大核心特性
 * 1.面向连接,所谓连接,指的是客户端和服务端的连接,在双方相互通信之前,TCP需要三次握手建立连接,而UDP没有相应建立
 * 连接的过程
 * 2.可靠性,TCP花了非常多的功夫保证连接的可靠,这个可靠性体现在哪些方面呢?一个是有状态,另一个是可控制
 * 
 * TCP会精准记录哪些数据发送了,哪些数据被对方接收了,哪些没有被接收到,而且保证数据包按序到达,不允许半点差错
 * 这是有状态
 * 
 * 当意识到丢包了或者网络环境不佳,tcp会根据具体的情况调整自己的行为,控制自己的发送速度或者重发.
 * 这是可控制
 * 
 * 相应的UDP是无状态\不可控的
 * 3.面向字节流.UDP的数据传输是数据包的,这是因为仅仅只是继承了ip层的特性,而tcp为了维护状态,将一个个ip包变成了字节流
 * 
 * 说说tcp三次握手的过程, 为什么是三次而不是两次或者四次
 * 
 * 恋爱模拟
 * 
 * 以恋爱模拟为例,两个人在一起最重要的事情就是首先确认各自爱和被爱的能力.接下来模拟三次握手过程
 * 第一次:
 * 男: w i n
 * 女方收到
 * 
 * 由此证明男方拥有爱的能力
 * 
 * 第二次:
 * 女: 我收到了你的爱, 我也爱你
 * 男方收到
 * 
 * ok,现在的情况说明,女方拥有爱和被爱的能力
 * 
 * 第三次:
 * 男方: 我收到了你的爱
 * 女方收到
 * 
 * 现在能够保证男方具备被爱的能力
 * 由此完整地确认了双方爱和被爱的能力,两人开始一段甜蜜的爱情
 * 
 * 真实握手
 * 
 * 对应到TCP的三次握手, 也是需要确认双方的两项能力,发送能力和接收能力
 * 
 * 从最开始双方都处于close状态,然后服务端开始监听某个端口,进入了LISTEN状态
 * 然后客户端主动发起连接,发送SYN,自己的状态变成SYN-SENT状态
 * 服务端接收到,返回SYN和ACK(对应客户端发送的SYN),自己变成SYN-REVD
 * 之后客户端再发送ACK给服务端,自己变成ESTABLISHED状态;服务端收到ACK之后,
 * 也变成了ESTABLISHED状态
 * 
 * 另外需要注意的是,从图中可以看出,SYN是需要消耗一个序列号的,下次发送对应的ACK序号要加一,
 * 为什么呢?只需要记住一个规则
 * 
 * 凡是需要对端确认的,一定消耗tcp报文的序列号
 * 
 * SYN需要对端确认,而ACK不需要,因此syn消耗了一个序列号而ack不需要
 * 
 * CLOSED                                   CLOSED
 *   |                                      LISTEN
 *   ---->          SYN, seq=x           -->  | 
 *   |                                        |
 * SYN-SENT                                   |
 *                                            |  
 *   |<---    SYN, ACK, seq=y, ack=x+1    <---|
 *   |                                        |
 *   |                                     SYN-RCVD
 *   |                                        |         
 *   |                                        | 
 *   ---->      ACK, seq=x+1, ack=y+1    -->  |
 *   |                                        |
 *   |                                        | 
 * ESTABLISHED   <--- 数据传输 --->       ESTABLISHED 
 * 
 * 为什么不是两次
 * 
 * 根本原因:无法确认客户端的接收能力
 * 分析如下:
 * 如果是两次,你现在发送了SYN报文想握手,但是这个包滞留在了当前网络中迟迟没有到达,TCP以为这个包丢了,于是
 * 重传,两次握手建立好了连接
 * 
 * 看似没有问题,但是连接关闭后,如果这个滞留在网路中的包到达了服务器端呢?这个时候由于是两次握手,服务端只要
 * 接收到然后发送相应的数据包,就默认建立连接,但是现在客户端已经断开.
 * 这就造成了一定的资源浪费
 * 
 * 为什么不是四次
 * 
 * 三次握手的目的是确认双方发送和接收的能力,那四次握手可以吗?
 * 当然可以,100次都可以,但三次就能解决问题,三次就能解决问题,再多用处就不大了
 * 
 * 三次握手过程中可以携带数据吗?
 * 第三次握手的时候,可以携带.前两次握手不能携带数据
 * 
 * 如果前两次握手携带数据,那么一旦有人想攻击服务器,那么他只需要在第一次握手中SYN报文中方大量数据,那么服务器
 * 势必会消耗更多的时间和内存空间去处理这些数据,增大了服务器被攻击的风险
 * 
 * 第三次握手的时候,客户端已处于ESTABLISHED状态,并且已经能够确认服务器的接收\发送能力正常,这个时候相对安全
 * 可以携带数据
 * 
 * 同时打开会怎样?
 * 
 * 如果双方同时发送SYN报文,状态变化会是怎样的呢?
 * 这是一个可能会发生的情况
 * 
 * 在发送方给接收方发送SYN报文的同时,接收方也给发送方发送SYN报文,两人刚上了
 * 发完SYN,两者的状态都变为SYN-SENT
 * 在各自接收到对方的SYN后,两者的状态都变为SYN-REVD
 * 接着会回复对应的ACK+SYN,这个报文在对方接收之后,两者状态一起变成ESTABLISHED
 * 
 * 说说TCP四次挥手的过程 
 * 
 * 刚开始双方处于ESTABLISHED状态
 * 客户端要断开了,想服务端发送FIN报文,在TCP报文中的位置如下图
 * 
 * 发送后客户端变为FIN-WAIT-1状态.注意,这时候客户端同时也变成了half-close(半关闭)状态,即无法想服务端
 * 发送报文,只能接收
 * 
 * 服务端接收到客户端确认,变成了CLOSE-WAIT状态
 * 
 * 客户端接收到服务端确认,变成FIN-WAIT2状态
 * 
 * 随后,服务端向客户端发送FIN,自己进入LAST-ACK状态
 * 
 * 客户端接收到服务端发来的FIN后,自己变成TIME-WAIT状态,然后发送ACK给服务端
 * 
 * 注意了,这个时候,客户端需要等待足够长的时间,具体来说,是2个MSL(Maximum Segment Lefttime,报文最大生存时间)
 * 在这段时间内,如果客户端没有收到服务端的重发请求,那么表示ACK成功到达,挥手结束,否则客户端重发ACK
 * 
 * 
 * ESTABLISHED         数据传输           ESTABLISHED
 *      |                                     |
 *      |--->        FIN, seq=p           --->|
 *      |                                     |
 * FIN-WAIT-1                                 |
 *      |<---       ACK, ack=p+1          <---|
 *      |                                     |
 * FIN-WAIT2                              CLOSE-WAIT
 *      |                                     |                                       
 *      |<---  FIN, ACK, seq=q, ack=p+1   <---|
 *      |                                     | 
 *      |                                  LAST-ACK
 *      |                                     |
 *      |--->        ACK, ack=q+1         --->| 
 *      |                                     |
 * TIME-WAIT                                CLOSED
 * (等待2MSL)
 *      |
 *    CLOSED
 * 
 * 等待2MSL的意义
 * 
 * 如果不等待会怎样
 * 
 * 如果不等待,客户端直接跑路,当服务器端还有很多数据包要发送给客户端,且还在路上的时候,若客户端的端口此时刚好
 * 被新的应用占用,那么就接收到了无用的数据包,造成数据包混乱,所以,最保险的做法是,等服务器发来的数据包都死翘翘
 * 再启动新应用
 * 
 * 那,照这样说一个MSL就不够吗?为什么要等待两个SML?
 * 1.1个SML确保四次挥手中主动关闭方最后的ACK报文最终能达到对端
 * 2.1个SML确保对端没有收到ACK重传的FIN报文可以到达
 * 
 * 这就是两个SML的意义
 * 
 * 
 * 为什么是四次挥手而不是三次挥手
 * 
 * 因为服务端在接收到FIN,往往不会立即返回FIN,必须等到服务端所有报文都发送完毕了,才能发送FIN.
 * 因此会先发送一个ACK表示已经收到客户端的FIN,延迟一段时间才发送FIN.这就造成了四次挥手
 * 
 * 如果是三次挥手会有什么问题
 * 
 * 等于说服务端ACK和Fin的发送合并为一次挥手,这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端
 * 从而让客户端不断重发FIN
 * 
 * 同时关闭会怎样?
 * 
 * 说说半连接队列和SYN Flood攻击的关系
 * 
 * 三次握手前，服务端的状态从CLOSED变为LISTEN，同时在内部创建了两个队列：半连接队列和全连接队列，即
 * SYN队列和ACCEPT队列
 * 
 * 半连接队列
 * 
 * 当客户端发送SYN到服务器，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入
 * 了SYN队列，也就是半连接队列
 * 
 * 全连接队列
 * 
 * 当客户端返回ACK，服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，他会被
 * 推入另外一个TCP维护的队列，也就是全连接队列
 * 
 * SYN Flood攻击原理
 * 
 * SYN Fllood属于典型的DOS/DDOS攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的ip地址，
 * 并向服务端疯狂发送SYN。对于服务端而言。会产生两个危险结果：
 * 
 * 1.处理大量的SYN包并返回对于的ACK，势必由大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理
 * 正常的请求。
 * 
 * 2.由于是不存在的ip，服务端长时间接收不到客户端的ACK，会导致服务端不断重复发数据，直到耗尽服务端资源
 * 
 * 如何应对SYN Flood攻击
 * 
 * 1.增加SYN连接，也就是增加半连接队列的容量
 * 2.减少SYN+ACK重试次数，避免大量的超时重发
 * 3.利用SYN Cookie技术，在服务端接收到syn后不立即分配连接资源，而是根据这个syn计算出一个cookie，连同
 * 第二次握手回复给客户端，在客户端回复ACK时带上这个cookie值，服务端验证cookie合法后才分配连接资源
 * 
 * 接收一下TCP报文头部字段
 * 
 * 报文头部的结构如下(单位位字节)：
 * 
 *          0     |      1     |      2     |      3
 *      源端口（Source port）   |  目标端口（Destination port）
 * |->             序列号（Sequence number）             <-|
 * |->         确认号（Acknowledgment number）           <-|
 *                |            |            |
 * =================================================================
 * ----------------------------0----------------------------
 * 头部长度     |       保留        |       ns
 * 
 * ----------------------------1----------------------------
 * CWR  |   ECE |   URG |   ACK |   PSH |   RST |   SYN |   FIN
 * 
 * ------------------------ 2 AND 3-------------------------
 * 窗口大小
 * =================================================================
 * 
 *       校验和（Checksum）     |   紧急指针（Urgent pointer）
 *              选项（Options）、填充（Padding）
 * 
 * 
 * 源端口、目标端口
 * 
 * 如何标识唯一标识一个连接？答案是TCP连接的四元组----源ip、源端口、目标ip和目标端口
 * 
 * 那tcp报文怎么没有源ip和目标ip呢？这是因为在ip层就已经处理了ip，tcp层只需要记录两者的端口即可
 * 
 * 序列号
 * 
 * 即Sequence number，本报文段第一个字节的序列号。
 * 
 * 从图中可以看出，序列号是一个长为4个字节，也就是32位的无符号整数，表示范围为：2^32 - 1。如果达到
 * 最大值了后就循环到0
 * 
 * 序列号在tcp通信的过程中有两个作用：
 * 1.在SYN报文中交换彼此的初始序列号
 * 2.保证数据包按正确的顺序组装
 * 
 * ISN
 * 
 * 即Initial Sequence Number（初始序列号），在三次握手的过程当中，双方会用SYN报文来交换彼此的ISN
 * 
 * ISN并不是一个固定的值，而是每4ms加一，溢出则回到0，这个算法使得猜测ISN变得很困难。那为什么要这么做？
 * 如果ISN被攻击者预测到，要知道源ip和端口都是很容易伪造的，当攻击者猜测ISN之后，直接伪造一个RST后，jjiu
 * 就可以强制关闭连接的，这是非常危险的
 * 
 * 而动态增长的ISN大大提高了猜测ISN的难度
 * 
 * 
 * 确认号
 * 即ACK（Acknowledgment number）。用来告知对方下一个期望接收的序列号，小于ACK的所有字节已全部接收
 * 
 * 标记位
 * 
 * 常见的标记位有SYN, ACK, FIN, RST, PSH
 * 
 * SYN和ack上文已经说过
 * 
 * SYN即Synchronize Sequence Numbers表示建立连接
 * FIN即finish表示发送方准备断开连接
 * RST即Reset，用来强制断开连接 
 * PSH即Push，告知对方这些数据包接收后应该立马交给上层的应用，不能缓存
 * 
 * 
 * 窗口大小
 * 
 * 占用两个字节，也就是16位，但实际上是不够用的。因此TCP引入了窗口缩放的选项，作为窗口缩方的比例因子
 * 这个比例因子的范围在0 ~ 14，比例因子可以将窗口的值扩大为原来的2^n次方
 * 
 * 校验和
 * 占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP直接丢弃之，等待重传
 * 
 * 可选项
 * 可选项的格式如下：
 * 
 * 种类（kind）1 byte   |    长度（length）1 byte   |   值（value）
 * 
 * 常用的可选项有以下几种：
 * 1.TimeStamp: TCP的时间戳，后面详细介绍
 * 2.MSS：指的是TCP允许的从对方接收的最大报文文段
 * 3.SACK：选择确认项
 * 4.Window Scale：窗口缩方选项
 * 
 * 
 * TCP快速打开的原理
 * 
 * 第一节讲了TCP三次握手，可能有人说，每次都三次握手好麻烦，能不能优化
 * 
 * 可以呀，今天我们说一说优化后的tcp握手流程，也就是TCP快速打开（TCP Fast open，即TFO）得原理
 * 
 * 优化得过程是这样得，还记得我们说SYN Flood攻击时提到的SYN Cookie吗？ 这个Cookie可不是浏览器的cookie
 * 用它同样可以实现TFO
 * 
 * TFO流程
 * 
 * 首轮三次握手
 * 
 * 首先客户端发送SYN给服务端，服务端接收到
 * 
 * 注意，现在不是服务端立即返回SYN + ACK,而是通过计算得到一个SYN Cookie，将这个Cookie放到TCP报文的
 * Fast Open选项中，然后才给客户端返回
 * 
 * 客户端拿到这个Cookie的值缓存下来。后面正常完成三次握手
 * 首轮三次握手就这么流程，而后面的三次握手就不一样了
 * 
 * 后面的三次握手
 * 
 * 后面的三次握手中，客户端会将之前缓存的Cookie、SYN和HTTP请求（是的你没有看错）发送给服务端，服务端
 * 验证了cookie的合法性，如果不合法直接废弃；如果合法那么就正常返回SYN+ACK
 * 
 * 重点来了,现在服务端能向客户端发http相应了！这是最显著的改变，三次握手还没有建立，仅验证了cookie的合法性
 * 就可以返回http响应了
 * 
 * 当然，客户端的ack还得正常传过来，不然怎么叫三次握手
 * 
 * 客户端                       服务端
 * 
 *       SYN, Cookie, http请求-》
 *                            验证cookie的合法性
 * 
 * <--         ACK + SYN
 * <--          HTTP响应    我现在可以发送http响应了
 * 
 *              ACK         --->
 * 
 * 注意：客户端最后一次握手的ACK不一定要等到服务端的http响应发送到达才发送，两个过程没有任何关系
 * 
 * TFO的优势
 * 
 * TFO的优势并不在首轮三次握手，而在于后面的握手，在拿到客户端的cookie并验证通过以后，可以直接返回http响应
 * 可以直接返回http响应，充分利用1个RTT（Round-Trip-time，往返时间）的时间提前进行数据传输，累计起来还是
 * 一个比较大的优势
 * 
 * 说说TCP报文中时间戳的作用？
 * 
 * timestamp是TCP首部的一个可选项，占用10个字节，格式如下：
 * kind（1个字节） + length（1个字节）+ info（8个字节）
 * 
 * 其中kind=8，length=10，info有两部分构成：timestamp和timestamp echo，各占4个字节
 * 
 * TCP 主要解决的两大问题
 * 1.计算往返延时RTT(Round-Trip time)
 * 2.防止序列号的回绕问题
 * 
 * 计算往返延时RTT
 * 
 * 在没有时间戳的时候，计算RTT会遇到的问题如下所示：
 * 
 * ·如果第一次发包为开始时间，就会出现作图的问题，RTT明显偏大，开始时间应该采用第二次的
 * ·如果第二次发包为开始时间，就会导致右图的问题，RTT明显偏小，开始时间应该采用第一次的
 * 
 * 实际上无论开始时间采用第一次的还是第二次发包，都是不准确的
 * 
 * 那这个时候时间戳很好的解决了这个问题。
 * 
 * 比如 a -> b 发送s1
 *      b -> a 回复一个s2
 * 
 * step1：a -> b 发送时， timestamp中存放的内容就是a主机发送时的内核时间ta1
 * step2：b -> a 回复时， timestamp中存放的时b主机的时刻ta，timestamp echo字段为从s1报文中解析的ta1
 * stap3：a 收到b发过来的报文后，此时a主键的内核时刻是ta2，而s2报文中的timestamp echo选项可以得到ta1，
 * 然后直接可以用ta2 - ta1 = RTT（计算往返延时）
 * 
 * 防止序列号回绕问题
 * 即使两次发包的序列号相同，时间戳也不可能相同，这就区分开了两个数据包
 * 
 * 
 * tcp的超时重传是如何计算的
 * 
 * TCP有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包，
 * 
 * 这个重传间隔也叫超时重传时间（Retransmission TimeOut 简称RTO）
 * 
 * 经典方法
 * 
 * 经典方法引入一个新的概念----SRTT（Smoothed round-trip time，即往返平滑时间），每产生一次新的RTT就根据
 * 一定的算法对SRTT进行更新，具体而言，计算方式如下（SRTT初始值为0）
 * 
 * SRTT =  (α * SRTT) + ((1 - α) * RTT)
 * α 平滑因子   建议值0.8，范围0.8~0.9
 * 
 * 拿到SRTT，我们就可以计算RTO的值
 * RTO = min(ubound, max(lbound, β * SRTT))
 * β是加权因子，一般为1.3 ~ 2.0， lbound下界， ubound上界
 * 
 * 其实这个算法还是很简单的，但是也存在一定的局限性，就是在RTT稳定的地方还可以，而在rtt变化较大的时候就不行了
 * 因为平滑因子范围是0.8~0.9,RTT对RTO的影响太小
 * 
 * 
 * 标准方法
 * 
 * 为了解决经典方法对于RTT的不敏感的问题，后面又引出了标准方法，也叫Jacobson/Karels算法
 * 一共又三部
 * 
 * 第一步：计算SRTT
 * 
 * SRTT = (1 - α) * SRTT + α * RTT
 * 注意这个时候的 α跟经典方法中的α取值不一样了，建议值是1/8，也就是0.125。
 * 
 * 
 * 第二部：计算RTTVAR(round trip time variation)这个中间变量
 * 
 * RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|)
 * 
 * 第三步：计算最终RTO
 * RTO = µ * SRTT + ∂ * RTTVAR 
 * µ建议值取1, ∂建议值取4。
 * 
 * 
 * 能不能说一下tcp的流量控制
 * 
 * 对于发送端和接收端而言，tcp需要把发送的数据放到发送缓存区，将接收的数据放到接收缓存区
 * 
 * 而流量控制索要做的事情，就是通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓冲区满了，就不能继续再发了
 * 
 * 要具体理解流量控制，首先需要了解滑动窗口的概念
 * 
 * TCP滑动窗口
 * 
 * TCP的滑动窗口分为两种，发送窗口和接收窗口
 * 
 * 发送窗口：包含四部分
 * 1.已发送且确认
 * 2.已发送但未确认
 * 3.未发送但可以发送
 * 4.未发送也不可以发送
 * 
 * 接收窗口
 * 
 * 流量控制过程
 * 
 * 首先双方三次握手，初始化各自的窗口大小，均为200字节
 * 
 * 假如当前发送端给接收端发送100字节，那么此刻对于发送端而言，SND.NXT当然要右移100字节，也就是说可以用窗口
 * 减少了100字节
 * 
 * 现在100个字节到达了接收端，被放到了接收端的缓存队列当中，不过此时由于大量负载的原因，接收端处理不了这么多
 * 字节，只能处理40个字节，剩余的60个字节被留在了缓存队列当中
 * 
 * 注意力，此时接收端的情况是处理能力不够了，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说
 * 缩小60个字节，又200变成了140字节，因为缓冲队列还又60字节每被应用拿走
 * 
 * 因此，接收端会在ack的报文首部带上缩小后的滑动窗口140字节，发送端对于的调整发送窗口未140字节
 * 
 * 此时对于发送端而言，已经发送且确认的部分增加40字节，也就是SND.UNA右移40个字节，同时发送窗口缩小为140字节
 * 
 * 这就是流量控制过程
 * 
 * 
 * 能不能说说TCP的拥塞控制
 * 
 * 上节所说的流量控制发生再发送端和接收端之间，并没有考虑到这个网络环境的影响，如果说当前网络特别差，特别容易丢包
 * 那么发送端就应该注意一些了，而这，也就是拥塞控制需要处理的问题
 * 
 * 对于拥塞控制来说，TCP每条连接都需要维护两个核心状态
 * ·拥塞窗口（Congestion Window, cwnd）
 * ·慢启动阈值（Slow start Threshold, ssthresh）
 * 
 * 设计到的算法有这几个
 * ·慢启动
 * ·拥塞避免
 * ·快速重传和快速恢复
 * 
 * 拥塞窗口cwnd，是指目前自己还能传输的数据量大小
 * 
 * 那么之前介绍了接收窗口的概念，两者有什么区别呢？
 * 
 * ·接收窗口（rwnd）是接收端给的限制
 * ·拥塞窗口（cwnd）是发送端的限制
 * 
 * 限制谁呢？
 * 
 * 限制发送窗口的大小
 * 
 * 有两个窗口，如何计算发送窗口？
 * 
 * 发送窗口的大小 = min(rwnd, cwnd)
 * 
 * 取两者中的较小着，而拥塞控制就是用靠控制cwnd的变化
 * 
 * 慢启动
 * 
 * 刚开始进入传输数据的时候，你是不知道现在的网络到底是稳定还是不稳定，如果做的太激进，发的包太急，那么疯狂丢包
 * 造成雪崩式的网络灾难
 * 
 * 因此，拥塞控制首先就要采用一种保守的算法来慢慢适应这个网络，这种算法叫做慢启动，运作过程如下：
 * 
 * ·首先，三次握手，双方宣告自己的接收窗口大小
 * ·双方初始化自己的拥塞窗口大小
 * ·在开始传输的一段时间，发送端每收到一个ACK，拥塞窗口大小加1，也就是说，每经过一个RTT，cwnd翻倍。
 * 如果初始窗口为10，那么第一轮10个报文传完并且发送端收到ACK后，cwnd变为20，第二轮变为40，第三轮变为80，以此类推
 * 
 * 难道就这么无止境的翻倍下去？当然不肯能，它的阈值叫做慢启动阈值，当cwnd到达这个阈值之后，好比踩了刹车
 * 
 * 到了阈值之后，如何控制cwnd的大小呢
 * 这就是拥塞避免要做的事情了
 * 
 * 拥塞避免
 * 
 * 原来每收到一个ACK，cwnd加1，现在到达了阈值，cwnd只能加这么一点1/cwnd。那你仔细算，一轮RTT下来，收到cwnd个
 * ACK,那最后拥塞窗口的大小才加1
 * 
 * 也就是说，以前一个RTT下来，cwnd翻倍，现在cwnd只加1
 * 
 * 当然，慢启动和拥塞避免是一起作用的，一体的
 * 
 * 快速重传和快速恢复
 * 
 * 快速重传
 * 
 * 在TCP传输过程中，如果发送丢包，即接收端发现数据端不是按顺序到达的时候，接收端的处理是重复发送之前的ACK
 * 
 * 比如第5个包丢了，即使6、7、个包到达了接收端，接收端也一律返回第4个包的ACK，当发送端收到3个重复的ACK时，
 * 意识到包丢了，于是马上进行重传，不用等到一个RTO时间到了才重传。
 * 
 * 着就是快速重传，它解决是否需要重传的问题
 * 
 * 选择性重传
 * 
 * 那你可能要问了，既然要重传，那么只传第5个包，还时5、6、7个包都要重传
 * 
 * 当然第6、7个包已经到达了，TCP设计着也不傻，针对性的重传
 * 
 * 快速恢复
 * 
 * 当然，发送端收到3个重复的ACK后，发现丢包，觉得现在的网络已经有些拥塞，自己会进入快速恢复阶段
 * 
 * 在这个阶段里，发送端如下改变
 * 
 * ·拥塞阈值降低为cwnd的一半
 * ·cwnd的大小变为拥塞阈值
 * ·cwnd线性增加
 * 
 * 以上就是TCP控制拥塞的经典算法，慢启动，拥塞避免、快速重传和快速恢复
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */