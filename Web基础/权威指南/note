ECMA 欧洲计算机制造协会

javascript是一种面向对象的编程语言，但又和传统的面向对象有很大区别

编程语言的词法结构是一套基础性规则，用来描述如何使用这门语言来编写程序。作为语法的基础，它规定了注入变量名时什么
样的、怎么写注释，以继程序之间如何分隔等规则。

字符集
javascript程序是用Unicode字符集编写的。Unicode是ASCII和Latin-1的超集，并支持地球上几乎所有在用的语言。
ECMAScript3要求javascript的实现必须支持Unicode2.1及后续版本，ECMAScript5则要求支持Unicode3及后续版本。

javascript是区分大小写的语言
html并不区分大小写（尽管XHTML区分大小写）
由于它和客户端javascript联系紧密，因此这点区别很容易混淆。许多客户端javascript对象和属性与他们所表示的HTML标签
和属性名同名。在HTML中，这些标签和属性名可以使用大写也可以是小写，而在javascript中必须是小写。
例如，在html中设置时间处理程序时，onclick属性可以写成onClick，但是javascript代码中，必须使用小写的onclick

空格、换行符和格式控制符
javascript会忽略程序中标识之间的空格。多数情况下，javascript同样会忽略换行符。由于可以在代码中随意使用空格
和换行，因此可以采用整齐、一直的缩进来形成统一的编码风格，从而提高代码的可读性
除了可以标识普通的空格符(\u0020),javascript还可以识别如下这些标识空格的字符：
水平制表符 \u0009
垂直制表符 \u000B
换页符     \u000C
不中断空白 \u00A0
字节序标记 \uFEFF

javascript将如下字符识别为行结束符：
换行符 \u000A
回车符 \u000D
行分隔符 \u2028
段分隔符 \u2029

回车符加换行符在一起被解析为一个单行结束符
Unicode格式控制字符，比如
从右至左写标记 \u200F
从左至右写标记 \u200E
控制着文本的视觉显示，这对于一些非英文文本的正确显示来说时至关重要的，这些字符可以用在JavaScript的注释、字符串直接量
额正则表达式直接量中，但不能用在标识符中，但有个例外，零宽连接  符 \u200D 和零宽非连接符 \uFEFF是可以出现咋标识符中的，
但不能作为标识符的首字符。

uniconde 转义序列
javascript定义了一种特殊序列，使用6个ASCII字符来代表任意16位Unicode内码，这些Unicode转义序列均已\u为前缀
其后跟随4个十六进制数（使用数字以及大写或小写字母A-F表示）。这种Unicode转义写法可以用在javascript字符串直接量、
正则表达式直接量和标识符中（关键字除外），如字符é的Unicode转义写法为\u00E9,如下两个javascript字符串是完全一样的：
'café' === 'caf\u00e9'  => true

Unicode转义写法也可以出现在注释中，但由于javascript会将注释忽略，他们只是被当成上下文中的ASCII字符处理，而且并不会被解析为对应的Unicode
Unicode允许使用多种方法对同一个字符进行编码。比如，字符'é'可以使用Unicode字符\u00e9标识，也可以使用普通的ASCII
字符e跟随一个语调符\u0301。在文本编辑器中，这两种编码的显示结果一模一样，但他们的二进制编码表示是不一样的，在计算机里
也不相等。Unicode标准为所有字符定义了一个首选的编码格式，并给出了一个标准化的处理方式将文本转换为一种合适比较的标准格式，
javascript会认为它在解析的程序代码已经是这种标准格式，不会再对其标识符、字符串或正则表达式作标准化处理

直接量
所谓直接量，就是程序中直接使用的数据值。
12
1.2
'hello world'
'Hi'
true
false
/javascript/gi
null
{x:1, y:2}
[1,2,3,4,5]

标识符和保留字
标识符就是一个名字。在javascript中，标识符用来对变量和函数进行命名，或者用做javascript代码中某些循环语句中的跳转位置的标记
javascript标识符必须以字母、下划线、或美元符号$开始。后续的字符可以是字母、数字、下划线或美元符号
（数字是不允许作为首字符出现的，以便javascript可以轻易区分开标识符和数字）
处于可移植性和易于书写的考虑，通常我们只使用ASCII字母和数字来来书写标识符。然而需要注意的是，
javascript允许标识符出现Unicode字符全集中的字母和数字。（从技术上讲，ECMAScript标准也允许在标识符的首字符后面出现Unicode字符集中的Mn类、Mc类和Pc类）

和其他任何编程语言一样，javascript保留了一些标识符作为自己所用。这些‘保留字’不能用做普通的标识符

保留字
javascript把一些标识符拿出来用作自己的关键字。因此，就不能再在程序中把这些关键字用作标识符了：
break delete function return typeof
case do if switch var
catch else in this void
continue false instanceof throw while
debugger finally new true with
default for null try

javascript同样保留了一些关键字，这些关键字在当前的语言版本中并没有使用，但在未来版本中可能会用到
ECMAScript 5 保留了这些关键字
class const enum export extends import super

此外，下面这些关键字在普通的javascript代码中是合法的，但是在严格模式下是保留字
implements let private public yield 
interface package protected static
严格模式同样对下面的标识符的使用做了严格限制，他们并不完全是保留字，但不能用做变量名、函数名或参数名：
argumens eval

可选的分号
和其他许多编程语言一样，javascript使用分号（；）将语句分隔开。这对增强代码的可读性和整洁性事非常重要的：
缺少分隔符，一条语句的结束就成了下一条语句的开始，反之亦然。在javascript中，如果语句各自独占一行，通常可以省略语句之间的分号
许多javascript程序员使用分号明确标记语句的结束，急事在并不完全需要分号的时候也是如此。另一种风格就是，在任何可以省略分号的地方都将其省略
只有在不得不用的时候才使用分号。不管采用哪种编程风格，关于javascript中可选分号的问题有几个细节需要注意。
考虑如下代码，因为两天语句用两行书写，第一个分号事可以省略掉的：
a = 3;
b = 4;
如果按照如下格式书写，第一个分号则不能省略掉：
a = 3; b = 4;
需要注意的事，javascript并不是在所有换行处都填补分号：只有在缺少了分号就无法正确解析代码的时候，javascript才会填补分号。
换句话讲（类似下面代码中的两处一场），如果当前语句和随后的非空格字符不能当成一个整体解析的化，javascript就在当前语句行结束处填补分号。
var a
a
=
3
console.log(a)
javascript将其解析为：
var a; a = 3; console.log(a)
javascript给第一行换行处添加了一个分号，因为如果没有分号，javascript就无法解析代码var a a 。‘
第二个a可以单独当作一条语句 'a;'，但javascript并没有给第二行结尾填补分号，因为他可以和第三行内容一起解析成a = 3
这些语句的分割规则会导致一些意想不到的情形，这段代码写成了两行，看起来是两条独立的语句：
var y = x + f
(a+b).toString()
但第二行的圆括号却和第一行的f组成了一个函数调用，javascript会把这段代码看作
var y = x + f(a+b).toString();
而这段代码的本意并不是这样。为了能让上述代码解析为两条不同的语句，必须手动填写行尾的显式分号。
通常来讲，如果一条语句以'(','[', '/', '+' 或 '-'开始，那么它极有可能和前一条语句合在一起解析。以'/','+'和'-'开始的语句并不常见
而以 （ 和 [ 开始的语句则非常常见，至少在一些javascript编码分格中时很普通的。有些程序员喜欢保守地在语句前加上一个分号，
这样哪怕之前的语句被修改了，分号被误删除了，当前语句还时会正确地解析：
var x = 0 //这里省略了分号
;[x, x+1, x+2].forEach(console.log) //前面的分号保证了正确的语句解析
如果当前语句和下一行语句无法合并解析，javascript则在第一行后填补分号，这是通用规则，但有两个例外。
第一个例外是在涉及return,break和continue语句的场景中。如果这三个关键字后紧跟着换行，javascript则会在换行处填补分号。
例如，这段代码：
return 
true
javascript会解析成：
return; true;
而代码的本意是这样的：
return true;
也就是说，在return, break和continue和随后的表达式之间不能有换行。如果添加了换行程序则只有在及特殊的情况下才会报错
而且程序的调试非常不方便。
2.是在设计 '++' 和 '--'运算符的时候。这些运算符可以作为表达式的前缀，也可以当作表达式的后缀。如果将其用做后缀表达式
它和表达式应当在同一行，否则，行尾将填补分号，同时'++' 或 '--'将会作为下一行代码的前缀操作符并与之一起解析，例如，这段代码：
x
++
y
这段代码讲解析为 'x; ++y', 而不是 'x++;y'
类型、值和变量
计算机程序的运行需要对值（value）进行操作。在编程语言中，能够表示并操作的值的类型称作数据类型，编程语言最基本的特性就是能够支持多种数据类型
当程序需要将值保存起来以备将来使用时，将其赋值给一个变量。变量是一个值的符号名称，可以通过名称来获得对值得引用
变量得工作机制是编程语言得另一个基本特性。
javascript得数据类型分为两类：
1.原始类型
数字、字符串、布尔值、
2.对象类型

javascript中有两种特殊得原始值：null（空）和undefined（未定义），他们不是数字、字符串和布尔值。他们通常分辨表示了
各自特殊类型得唯一成员
javascript中数字、字符串、布尔值、null和undefined之外的就是对象了。对象object是属性的集合，每个属性都由‘名/值对’
（值可以是原始值，比如数字、字符串，也可以是对象）构成。其中有一个比较特殊的对象---全局对象（global object）
普通的javascript对象是’命名值‘的无序集合。javascript同样定义了一种特殊对象--数组，带有编号的值的有序集合。
javascript为数组定义了专用的语法，使数组拥有一些和对象不同的特有行为特性。
javascript还定义了另一种特殊对象---函数。函数是具有与它相关的可执行代码的对象，通过调用函数来运行可执行代码，并返回运算结果
和数组一样，函数的行为特征和其他对象都不一样。javascript为使用函数定义了专用语法。对于javascript函数来讲，最重要的是，
他们都是真值，并且javascript可以将他们当作普通对象来对待
如果函数用来初始化（使用new运算符）一个新建的对象，我们称之为构造函数（constaructor）。每个构造函数定义了一类对象---由构造函数初始化的对象组成的集合
类可以看作是对象类型的子类型。
除了数组类和函数类之外，javascript语言核心定义了其他三种有用的类
1.日期类定义了代表日期的对象。
2.正则类定义了表示正则表达式（一种强大的模式匹配工具）的对象
3.错误类定义了那些表示javascript程序中运行时错误和语法错误的对象
可以通过定义自己的构造函数来定义需要的类
javascript解释器有自己的内存管理机制，可以自动对内存进行垃圾回收。这意味着程序可以按需创建对象，程序员则不必淡些这些对象的销毁和内存回后。
当不再有任何引用指向一个对象，解释器就会知道这个对象没用了，然后自动回收他所占用的内存资源。
javascript是一种面向对象的语言。不严格地讲，这意味着我们不用全局的定义函数去操作不同类型的值，数据类型本身可以定义方法来使用值
例如
要对数组a中的元素进行排序，不必要讲a传入sort()函数，二十调用a的一个方法sort()
a.sort(); //sort(a)的面向对象的版本
从技术上讲，只有javascript对象才能拥有方法。然而，数字、字符串和布尔值也可以拥有自己的方法。
在javascript中，只有null和undefined是无法拥有方法的值。
javascript的类型可以分为原始类型和对象类型，也可分为拥有方法的类型和不能拥有方法的类型，同样可分为可变类型和不可变类型。
可变类型的值是可修改的。对象和数组属于可变类型：javascript程序可以改变对象属性值和数组元素的值。数字、布尔值、null和undefined属于不可变类型
比如修改一个数值的内容本身就是说不通。字符串可以看成由字符组成的数组，你可能会认为他是可变的。然而javascript中，
字符串是不可变的：可以访问字符串任意位置的文本，但javascript并未提供修改已知字符串的文本内容的方法
javascript可以自由地进行数据类型转换。比如，如果在程序期望使用字符串的地方使用了数字，javascript会自动讲数字转换为字符串。
如果在期望使用布尔值的地方使用了非布尔值，javascript也会进行相应的转换。
javascript中灵活的类型转换规则对’判断相等‘的定义亦有影响。等号运算符'=='
js变量是五类线的，变量可以被赋予任何类型的值，同样一个变量也可以重新赋予不同类型的值。使用var关键字来声明变量
javascript采用词法作用域lexical scoping 。不在任何函数内声明的变量称作全局变量，它在javascript程序中的任何地方都是可见的
在函数内声明的变量具有函数作用域function scope，并且旨在函数内可见。
3.1数字
和其他编程语言不同，javascript不区分整数值和浮点数值。
js中的所有数字均用浮点数值表示。js采用IEEE754标准 定义的64位浮点格式表示数字，这意味着他能表示的最大值是（+|-）1.7976931348623157 * 10^308，最小值是(+|-)5*10^-324
按照js中的数字格式，能够表示的整数范围是从-9007199254740992——9007199254740992即-2^53 -- 2^53，包含边界值。如果使用了超过此范围的整数，则无法保证低位数字的进度。
然而需要注意的是js中实际的操作（比如数组索引，以及位操作符）则是基于32位整数
当一个数字直接出现在js程序中，我们称之为直接量。js支持多种格式的数字直接量，
在任何数字直接量前添加负号（-）可以得到他们的负值。但负值是一元求反运算符，并不是数字直接量语法的组成部分
整型直接量
在js程序中，用一个数字序列表示一个十进制整数
例如:
0
3
10000000
除了十进制的整型直接量，js同样能识别十六进制值。所谓十六进制的直接量是指以'0x'或'0X'为前缀，后面跟随十六进制字符串的直接量。
十六进制值是0~9时间的数字和a(A)~f(F)之间的字母构成，a~f的字母对于的表示数字10~15
下面是十六进制整型直接量的例子：
0xff //15*16 + 15 = 255（十进制）
0xCAFE911
尽管ECMAScript标准不支持八进制直接量，但js的某些实现可以允许采用8进制形式表示整数。八进制直接量以数字0开始，其后跟随一个由0~7之间的数字组成的序列，
例如，
0377 //3*64 + 7*8 + 7  = 255
由于某些js的实现支持把机制直接量，而有些不支持，因此最好不要使用以0为前缀的整型直接量，毕竟我们也无法得知当前js的实现是否支持八进制的解析
在ECMAScript6的严格模式下，八进制直接量是命令禁止的
3.1.2浮点型直接量
浮点型直接量可以含有小数，他们采用的是传统的实数写法。一个实数由整数部分、小数点和小数部分组成。
此外，还可以使用指数计数法表示浮点直接量，即在实数后跟字母e或者E，后面在跟负号，其后再加一个整型的指数。这种计数方法表示的数值，
是由前面的实数乘以10的指数次幂
可以使用更简洁的语法表示：
[digits][.digits][(E|e)[(+|-)]digits]
例如：
3.14
2345.789
.33333333
6.02e23 //6.02*10^23
1.4738223E-32 //1.4738223*10^-32
3.1.3js中的算术运算
js程序是使用语言本身提供的算术运算符来进行数字运算的。这些运算符包括加法运算符(+),减法运算符（-），乘法运算符（*），除法运算符（/）和求余（求整除后的余数）运算符(%)
除了基本的运算符外，js还支持更加复杂的算术运算，这些复杂运算通过作为Math对象的属性定义的函数和常量来实现：
Math.pow(2,53) //2的 53次幂
Math.round(.6)  //1.0 四舍五入
Math.ceil(.6)   //1.0 向上求整
Math.floor(.6)   //0.0向下求整
Math.abs(-5)   //5 求绝对值
Math.max(x, y, z)   //返回最大值
Math.min(x, y, z) //返回最小值
Math.random()  生成一个大于等于0小于1.0的伪随机数
Math.PI   //Π  圆周率
Math.E      //e 自然对数的底数
Math.sqrt(3)  //3的平方根
Math.pow(3, 1/3) //3的立方根
Math.sin(0) //三角函数：还有Math.cos, Math.atan
Math.log(10) //10的孜然对数
Math.log(100)/Math.LN10  以10为底100的对数
Math.log(512)/Math.LN2 以2为底512的对数
Math.exp(3)  //e的三次幂
参阅第三部分中关于Math对象的介绍，这里列出了js所支持的所有数学函数
js中的算术运算再溢出（overflow）、下溢（underflow）或被0整除时不会报错。当数字运算结果超过js所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值
再js中以Infinity表示。同样地，当负数的值超过js所能表示的负数范围，结果为负无穷大，在js中以-Infinity表示。
无穷大致的行为特殊和我们所期望的时一致的：基于他们的加、减、乘和除运算结果还时无穷大值（当然还保留他们的正负号）
下溢(underflow)时当运算结果无限接近于零并比js能表示的最小值还笑的时候发生的一种情况。这种情况下，js将会返回0.当一个负数发生下溢时
js返回一个特殊的值‘负零’。这个值几乎和正常的零完全一样，js程序员很少用到负零
被零整除在js并不报错：它只是简单的返回无穷大（Infinity）或负无穷大(-Infinity)。但有一个例外，
零处以零是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值，用NaN表示。
无穷大处以无穷大、给任意负数做开方运算或着算术运算符与不是数字或无法转换为数字的操作数一起使用时都将返回NaN。
js预定义了全局变量Infinity和NaN,用来表示正无穷大和非数字值。在es3中，这两个值时可读/写的，并可修改。es5修正了这个错误，
将他们定义为只读的。es3中Number对象定义的属性值也是只读的。
INFINITY //将一个可读写的变量初始化为infinity
Number.POSITIVE_INFINITY //同样的值，只读
1/0   这也是同样的值
Number.MAX_VALUE + 1   //计算结果还时Infinity
nUMBER.NEGATIVE_INFINITY //该表达式表示了负无穷大
-Infinity表示。-1/0
-Number.MAX_VALUE - 1
NaN   //将一个可读写的变量初始化为NaN
Number.NaN  同样的值，但是只读
0/0   计算结果时NaN
Number.MIN_VALUE/2发生下溢：计算结果为零
-Number.MAIN_VALUE/2  //负零
-1/Infinity  同样时负零
-0
js中的非数字值有一点特殊：它和任何值都不相等，包括自身。也就是说，没有办法通过x == NaN来判断变量x是否是NaN。相反，
应当使用x != X 来判断，当且仅当x为NaN的时候，表达式的结果才为true，函数isNaN()的作用于此类似，如果参数是NaN或者是一个非数字值
（比如字符串和对象），则返回true。js中有一个类似的函数isFinie(),在参数不是NaN、Infinity或-Infinity的时候返回true
负零值同样有些特殊，它和正零值是相同的（甚至使用js的严格相等测试来判断）。着意味着这两个数值基于一模一样，除了作为除数之外
var zero = 0  //正常的零值
var negz = -0; //负零值1
zero === negz   true  正零值和负零值相等
1/zero === 1/negz false 正无穷大和负无穷大不等
3.14二级制浮点数和四舍五入错误
实数由无数个，但js通过浮点数的形式只能表示其中有限的个数（切确地说是18 437 736 874 454 810 627个）。也就是说
在js中使用实数的时候，常常只是真实值的近似表示
js采用IEEE-754浮点数表示法（几乎所有现代编程语言所采用），这是一种二进制表示法，可以精确地表示分数，比如1/2、1/8
和1/1024。遗憾的是，我们常用的分数（特别是在金融计算方面）都是十进制分数1/10、1/100等。二进制浮点数表示法并不能
精确表示类似0.1摄影简单的数字
js的数字具有足够的精度，并可以及其近似于0.1.但事实是，数字不能精确表述的确带来了一些问题。
var x = .3 - .2; //30美分减去20美分
var y = .2 - .1; 20美分减去10美分
x == y   false两值不相等
x == .1  false .3 - .2 不等于 .1
y == .1  true  .2 - .1 等于.1
由于摄入误差，0.3和0.2之间的近似差值实际上并不等于0.2和0.1之间的近似插值。这个问题并不只在js中才会出现，理解这一点非常重要；
在盛和使用二进制浮点数的编程语言都会有这个问题。童谣需要注意的是，上述代码中x和y的值非常接近彼此和最终的正确值。这种计算结果
可以胜任大多数的计算任务：这个问题也只有在比较两个值是否相等的时候才会出现
js的未来办好或许会支持十进制数字类型以避免这些舍入问题。在这之前你可能更愿意使用大整数进行重要的金融计算，例如
要使用整数‘分’而不要使用小数‘元’进行基于或不单位的运算
3.1.5日期和时间
js语言核心包括Date()构造函数，用来创建表示日期和时间的对象。这些日期对象的饿方法为日期计算提供了简单的API。日期对象
不像数字那样是基本数据类型。
var then = new Date(2011, 0, 1) //2011年1月1日
var later = new Date(2011, 0, 1, 17, 10, 30) //同一天，当地时间5：10：30pm
var now = new Date()当前日期和时间
var elapsed = now - then; //日期减法  计算时间间隔的毫秒数
later.getFullYear()  2011
later.getMonth()  0 从0开始计数的月份
later.getDate()  1 从1开始计算的天数
later.getDay() 5得到星期几， 0表示星期日，5代表星期一
later.getHours() 当地时间17：5pm
later.getUTCHours() 使用UTC表示小时的时间，基于时区
3.2文本
字符串(string)是一组由16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集。js通过字符串类型来表示文本。
字符串的长度length是其所含16位值得个数。js字符串（何其数组）得索引从零开始；第一个字符得位置是0，第二个字符得位置是1
以此类推。空字符串长度位0，js中并没有表示单个字符得字符型。要表示一个16位值，只需将其赋值给字符串变量即可，这个字符串长度位1.
字符集，内码和js字符串
js采用UTF-16编码得Unicode字符集，js字符串是由一组无符号得16位值组成的序列。最常见得Unicode字符集(这些字符属于“基本多语种平面”)
都是通过16位得内码表示，并代表字符串中得单个字符，哪些不能表示位16位得Unicode字符则遵循UTF-16编码规则--用两个16位值组成一个序列（亦称作“代理项对”）表示。
这意味着一个长度位2得js字符串（两个16位值）有可能表示一个Unicode字符：
var p = 'π'  //π由16位内码表示0x03c0
var e = '𝑒' e由17位内码表示0x1d452
js定义了各种字符串操作方法均用于16位值，而非字符串，并不会对代理项对做单独处理，同样js不会对字符串做标准化得加工
甚至不能保证字符串是合法得UTF-16格式
3.2.1字符串直接量
在js程序中的字符串直接量，时由单引号或双引号括起来的字符序列。由单引号定界的字符串中可包含双引号，由双引号丁洁的字符串中也可以包含单引号。
这里有几个字符串直接量的例子：
"" //空字符串：它包含0个字符
'testing'
"3.14"
'name="myform"'
"wouldn't you prefer 0' Reilly's book?"
"This string\nhas two lines"
"𝑒 is the ratio of a circle's circumference to its diameter"
在ECMAScript3中，字符串直接量必须写在一行中，而在ECMAScript5中，字符串直接来可以拆分成竖行，每行必须以反斜线（\）结束，反斜线
和行结束符都不算是字符串直接量的内容。如果希望在字符串直接量中另起一行，可以使用转义字符\n
"two\nlines" //定义一个显示为两行的字符串
"one\
long\
line" //用三行代码定义了显示为单行的字符串，只在ECMAScript5中可用
需要注意的是，当 使用单引号来定界字符串时，需要格外小心英文中的缩写和所有格写法，比如can't 和O’Reailly's。因为撇号和单引号时同一个字符，所以必须使用反斜线来转义所有的撇号
在客户端js程序设计中，js代码会夹杂html代码的字符串，html代码也会夹杂js代码。和js一样，html也使用单引号或者双引号来定界字符串
因此，当js代码和html代码混杂在一起的时候，做好在js和html代码中各自使用独立的引号风格。例如，在js表达式中使用单引号表示字符串'Thank you'
而在html事件处理程序数学中使用双引号表示字符串：
<button onclick="alert('Thank you')">Click Me</button>
3.2.2转义字符
js字符串中，反斜线\有着特殊的作用，反斜线符号后加一个字符，就不在表示他的字面含义了。比如\n就是一个转义字符，它表示的是一个
换行符。
另外一个例子是上节中提到的转义字符\'，表示单引号（或撇号）.当需要在一个单引号定界的字符串内使用撇号的时候，他就显得非常有用
反斜线可以使我们避免使用常规方式解释单引号，当单引号不是用来标记字符串结尾时，它只是一个撇号：
'You\'re right, it can\'t be a quote'
其中有两个通用的，通过十六进制数表示Latin-1或Unicode中的任意字码。
例如，\xA9表示版权符号，版权符号的Latin-1编码时十六进制数A9。同样，\u表示由4个十六进制数指定的任意Unicode字符，比如
\u03c0表示字符（Π）
转义字符        含义
\o      NUL字符（\u0000）
\b      退格符(\u0008)
\t      水平制表符（\u0009）
\n      换行符(\u000A)
\v      垂直制表符(\u000B)
\f      换页符(\u000C)
\r      回车符(\u000D)
\"      双引号(\u0022)
\'      撇号或单引号
\\      反斜线
\xXX    由两位十六进制数XX制定的Latin-1字符
\uXXXX 由4位十六进制数XXXX指定的Unicode字符
3.2.3字符串的使用
js的内置功能之一就是字符串连接。如果将加号运算符用于数字，表示两数相加。但将它作用于字符串，则表示字符串连接，将第二个字符串拼接在第一个之后
msg =  'Hello, ' + 'world'
greeting = 'welcome to my blog, ' + ' ' + name;
要确定一个字符串的长度--其所包含的16位值得个数---可以使用字符串得length属性。比如，要得到字符串s得长度
s.length
除了length属性，字符串还提供许多可以调用得方法
var s = 'hello, world'  //第一一个字符串
s.charAt(o)   //h:第一个字符
scharAt(s.length-1) //d:最后一个字符
s.substring(1,4)  //ell 第2~4个字符
s.slice(1,4)   //ell同上
s.slice(-3)   //rld 最后三个字符
s.indexOf('l')   //2 字符l首次出现的位值
s.lastIndexOf('l')  //10 字符l最后一次出现的位值
s.indexOf('l', 3)   //3在位值3级之后首次出现字符l的位值
s.split(',') //["hello", "world"]分割成子串
s.replace('h', "H")  //Hello, world 全文字替换
s.toUpperCase()     //HELLO,WORLD 
记住，在js中字符串时固定不变的，类似replace()和toUpperCase()的方法都返回新字符串，原字符串本身并没有发生改变
在ECMASCRIPT5中，字符串可以当作只读数组，除了使用charAt()方法，也可以使用方括号来访问字符串的单个字符（16位值）
s = 'hello, world'
s[0]
s[s.length-1]
基于Mozilla的Web浏览器(比如Firefox)很久之前就支持这种方式的字符出索引，多数现代浏览器（IE除外）也紧跟Mozilla的脚步
在ECMAScript5成型之前就支持了这一特性。
3.2.4模式匹配
js定义了RegExp()构造函数，用来创建表示文本匹配模式的对象。这些模式称之为‘正则表达式’，js采用perl中的正则表达式语法。
string和RegExp对象均定义了利用正则表达式进行模式匹配和查找替换的函数。
RegExp并不是js的基本类型。和Date一样，它只是一种具有使用API的特殊对象。正则表达式的语法很复杂，API也很丰富
尽管RegExp并不是语言中的基本数据类型，但是他们依然具有直接量写法，可以直接在js程序中使用。在两条斜线之间的文本构成了一个正则表达式直接量。
第二条斜线之后也可以跟随一个或多个字母，用来修饰匹配模式的含义，例如：
/^HTML/  //匹配以HTML开始的字符串
/[1-9][0-9]*/  //匹配一个非零数字，后面时任意个数字，后面时任意个数字
/\bjavascript\b/i //匹配单词 javascript, 忽略大小写
RegExp对象定义了很多有用的方法，字符串同样具有可以接收RegExp参数的方法，例如：
var text = 'testing:1, 2, 3'
var pattern = /d+/g  //匹配所有包含一个或多个数字的实例
pattern.test(text) true 匹配城关
text.search(pattern)  9 首次匹配城关的位值
text.match(pattern)  ['1', '2', '3']所有匹配组的数组
text.replace(pattern, '#')   //texting: #, #, #
text.split(/\D+/)  ['', '1', '2', '3'] 用非数字字符串截取字符串
3.3布尔值
布尔值指代真或假、开或关。这个类型只有两个值，保留字true和false
js程序中的比较语句的结果通常都是布尔值，例如：
a == 4
这段代码用来检测变量a的值是否等于4.如果等于，比较结果的布尔值就是true；如果不等于，比较结果则位false。
布尔值通常用于js中的控制结构中。例如js中的if/else语句，如果布尔值位true执行第一段逻辑，如果为false执行另一段多级。
通常将一个创建布尔值的比较直接于使用这个比较的语句结合在一起结果如下所示：
if(a == 4)
b = b + 1;
else
a = a + 1;
任意js的值都可以转换为布尔值。
下面的值将被转换为false
undefined
null
0
-0
NaN
''//空字符串
所有其他值，包括对象（数组）都会转换成true。false 和上面6个可以转换成false的值有时称作‘假值’，其他值称作真值
js期望使用一个布尔值的时候，假值会被当成false，真值会被当成true
假设变量o是一个对象或是null，可以通过一条if语句来显示地检测o是否是非null值：
if(o !== null)
不等操作符 '!==' 将o和null比较，并得出结果为true或false。可以先忽略这里的比较语句，null是一个假值，对象是一个真值
if(o)....
对于第一种情况，只有当o不是null时才会执行代码，第二种情况没有那么严格：只有o不是false或任何假值（比如null或undefined）
时它才会执行这个if。到底选那条语句取决于期望赋值给O的值时什么，如果需要将null于''区分卡，则需要使用一个显示的比较。
布尔值包含toString()方法，因此可以使用这个方法将字符串转换为true或false，但它并不包含其他有用得方法。除了这个不重要的API
还由三个重要的布尔运算符。
&& 运算符执行了逻辑与（AND）操作。当且仅当两个操作数都是真值时它才返回true；否则返回false
||运算符时布尔或(OR)操作，如果两个操作数其中之一为真值它就返回true，如果两个操作数都是假值则返回false
！一元操作符执行了布尔非(NOT)操作：如果操作数时真值则返回false；如果是假值，则返回true
if((x==0 && y == 0) || !(z == 0)){
    //x和y都是零或z是非零
    3.4null和undefined
    null是js语言关键字，它表示一个特殊值，常用来描述‘空值’。对null执行typeof预算，结果返回字符串'object'，也就是说
    可以将null认为是一个特殊的对象值，含义是‘非对象’。但实际上，通常认为null是它自有类型的唯一一个成员，
    它可以表示数字、字符串和对象是‘无值’的。大多数编程语言和js一样含有null，
    js还由第二个值来表示值得空缺。用未定义得值表示更深层次得‘空值’。它是变量得一种取值，表明变量没有初始化，如果要查询对象属性或数字元素得值时
    返回undefined则说明这个属性或元素不存在。如果函数没有返回任何值，则返回undefined，引用没有提供实参的函数形参的值也会只得到undefined.
    undefined是预定义的全局变量（它和null不一样，他不是关键字），它的值就是‘未定义’
    在ECMAScript3中，undefined是可读写的变量，可以给它赋任意值。这个错误在ES5中修正了，undefined在该版本中是只读的
    如果使用typof运算符得到undefined的类型，则返回undefined，表明这个值是一个类型的唯一成员 
尽管null和undefined是不同的，但他们都表示“值得空缺”,两者往往可以互换。判断相等运算符"=="认为两者是相等的（要使用严格相等运算符 “===” 来区分他们）。
在希望值布尔值的地方他们的值都是假值，和false类似。null和undefined都不包含任何属性和方法。使用上，使用'.'和'[]'来存取这个值的成员或方法都会产生一个类型错误
你或许认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序及的、正常的或在意料中的值得空缺，
如果你想将他们赋值给变量或者属性，或者将他们作为参数传入函数，最佳选择是使用null
3.5全局对象
前几节讨论了js的原始类型和原始值。对象类型-对象、数组和函数--
全局对象：在js中有着重要的用途：全局对象的属性是全局定义的符号，js程序可以直接使用。当js解释器启动时（或者任何web浏览器加载新页面的时候）
它将创建一个新的全局对象，并给它一组定义的初始属性：
全局属性，比如undefined、 Infinity和NaN
全局函数，比如isNaN()、parseInt()和eval()
构造函数，比如Date(),RegExp(),String(),Object()和Array()
全局对象，比如Math和JSON
全局对象的初始属性并不是保留字，但他们应该当作保留字来对象。
在代码的最顶级---不在任何函数内的js代码---可以使用js关键字this来引用全局对象
var global = this; //定义一个引用全局对象的全局变量
在客户端js中，在其表示的浏览器窗口中的所有js代码中，window对象充当了全局对象。这个全局window对象有一个属性window
引用其自身，它可以代替this来引用全局对象。window对象定义了核心全局属性，但它也针对web浏览器和客户端js定义了一少部分其他全局属性
当初次创建的时候，全局对象定义了js中所有的预定义全局值。这个特殊对象同样包含了为程序定义的全局值，如果代码声明了一个全局变量，
这个全局变量就是全局对象的属性
3.6包装对象
js对象是一种复合值：它是属性或已命名值得集合。通过'.'符号来引用属性值。当属性值是一个函数得时候，称其为方法。通过o.m()来调用对象o中得方法。
我们看到字符串也同样具有属性和方法；
var s = 'hello world'
var word = s.substring(s.indexOf(' ')+1, s.length)
字符串既然不是对象，为什么它会有属性呢?只要引用了字符串s得属性，js就会将字符串值通过调用new String(s)得方式转换成对象，
这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁（其实在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样的）
同字符串一样，数字和布尔值也具有各自的方法：通过Number() 和 Boolean()构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。
null和undefined没有包装对象，访问他们的属性会造成一个类型错误
var s = 'test'
s.len = 4
var t = s.len;
当允许这段代码时，t的值时undefined。第二行代码创建一个临时字符串对象，并给其len属性赋值为4，随即销毁这个对象。
第三行通过原始的（没有被修改锅）字符串值创建一个新字符串对象，尝试读取len属性，这个属性自然不存在，表达式求值结果为undefined。
这段代码说明了在读取字符串、数字和布尔值的属性值（或方法）的时候，表现得像对象一样。但如果你试图给其属性赋值，则会忽略这个操作：
修改只是发生在临时对象身上，而这个临时对象并未继续保留下来
存取字符串、数字或布尔值得属性时创建得临时对象称作包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。
通常，包装对象只是被看作是一种实现细节，而不用特别关注。由于字符串、数字和布尔值得属性都是只读得，并不能给他们定义新属性，
因此你需要明白他们是有别于对象得。
需要注意得是，可通过string()，Number()或Boolean()构造函数来显示创建包装对象：
var s = 'test', n = 1, b = true;
var S = new String(s)
var N = new Number(n)
var B = new Boolean(b)
js会在必要时将包装对象转换成原始值，因此上段代码中得对象S,N和B常常---但不总时---表现得和s,n和b一样。
'=='等于运算符将原始值和其包装对象视为相等，但 '==='全等运算符将他们视为不等。通过typeof运算符可以看到原始值和包装对象得不同
3.7不可变的原始值和可变的对象引用
js中的原始值(undefined,null,布尔值，数字和字符串)与对象（包括数组和函数）有着根本的区别。
原始值时不可改变的：任何方法都无法更改一个原始值。对数字和布尔值来说显然如此--改变数字的值本身就说不同，而对字符串来说
就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来修改字符串中的字符。实际上，js是禁止这样做的。
字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。例如：
var s = 'hello'     定义一个由小写字母组成的文本
s.toUpperCase()     返回'HELLO' 但并没有改变s的值
s       'hello' 原始字符串的值并未改变
原始值的比较是值的比较：只有在他们得值相等时他们才相等。这对数字、布尔值、null和undefined来说听起来有点难懂，并没有其他办法来比较他们
同样，对于字符串来说则并不明显。如果比较两个单独的字符串，当且仅当他们的长度相等切每个索引的字符都相等时，js才认为他们相等
对象和原始值不同，首先，他们时可变的---他们的值时可修改的
var o = {x:1}
0.x = 2;
o.y = 3;
var a = [1, 2, 3]
a[0] = 0
a[3] = 4;
对象的比较并非值得比较：即使两个对象包含同样的属性及相同得值，他们也是不相等得，各个索引元素完全相等的两个数组也不相等
var o = {x:1}, p = {x:1}
o === p
var a = [], b = []
a === b
我们通常将对象称为引用类型，以此来和js的基本类型区分开来，依照术语的叫法，对象值都是引用，对象的比较均时引用的比较：
当且仅当他们引用同一个及对象时，他们才相等
var a = []
var b = a;
b[0] = 1;
a[0]
a === b
就像你刚看到的如上代码，将对象（或数组）赋值给一个变量，仅仅时赋值的引用值：对象本身并没有复制一次。如果你想得到一个对象或数组的副本，则必须显示复制对象的每个属性或数组的每个元素。
var a = ['a', 'b', 'c']
var b = []
for(var i=0; i< a.length; i++){
    b[i] = a[i]
同样的，如果我们相比较两个单独的对象或者数组，则必须比较他们的属性或元素。
function equalArrays(a,b){
    if(a.length != b.length) return false;
    for(var i=0; i<a.length;i++)
        if(a[i]=b[i]) return false;
    return true
}
}
3.8类型转换
js中的取值类型非常灵活，我们已经从布尔值看到了这一点：当js期望使用一个布尔值的时候，你可以提供任意类型值，js将根据需要自行转换类型。
一些值（真值）转换为true，其他值（假值）转换为false。这在其他类型中同样适用
如果js期望使用一个字符串，它把给定的值将转换为字符串，如果js期望使用一个数字，他把给定的值转换为数字（如果转换结果无意义的话将返回NaN）
10 + ' objects'  // '10 objects' 数字10 转换成字符串
'7' * '4'   //28 两个字符串均转换为数字
var n = 1 - 'x' //NaN 字符串x无法转换为数字
n + ' objects'   // 'NaN objects' NaN转换为字符串'NaN'
值          转化为
            字符串          数字        布尔值      对象
undefined   'undefined'     NaN         false       throws TypeError
null        'null'          0           false       throws TypeError

true        'true'          1                       new Boolean(true)
false       'false'         0                       new Boolean(false)

''                          0           false       new String('')
'1.2'                       1.2         true        new String('1.2')
'one'                       NaN         true        new String('one')

0           '0'                         false       new Number(0)
-0          '0'                         false       new Number(-0)
NaN         'NaN'                       false       new Number(NaN)
Infinity    'Infinity'                  true        new Number(Infinity)
-Infinity   '-Infinity'                 true        new Number(-Infinity)
1(无穷大)   '1'                         true        new Number(1)
{}                                      trie
[]          ''              0           true        
[9]         '9'             9           true
['a']       使用join()      NaN         true
function(){}                NaN         true

原始值到对象的转换也非常简单，原始值通过调用String(), Number(), Boolean()构造函数，转化为他们各自的包装对象
null和undefined属于例外，当将他们用在期望是一个对象的地方都会造成一个类型错误(TypeError)异常，而不会执行正常的转换、
3.8.1转换和相等性
由于js可以做灵活的类型转换，因此其'=='相等运算符也随相等的含义灵活多变。
如，如下这些比较结果均是true
null == undefined   //这两值被认为相等
'0' == 0 //在比较之前字符串转换成数字
0 == false  //在比较之前布尔值转换成数字
'0' == false    //在比较之前字符串和布尔值都转换成数字
需要特别注意的是，一个值转换为另一个值并不意味着两个值相等。比如，如果在期望使用布尔值的地方使用了undefined，它将会转换为false，
但这并不表示undefined == false js运算符和语句期望使用多样化的数据类型，并且可以相互转换if语句将undefined转换为false，但'=='运算符从并不视图将其操作数转换为布尔值
3.8.2显示类型转换
尽管js可以自动做许多类型转换，但有时仍需要做显式转换，或者为了是代码变得清晰易读而做显示转换。
做显式转换最简单的方法就是使用Boolean() Number() String() Object() 函数，当不通过new运算符调用这些函数时，他们
会作为类型转换函数
Number('3')    //3
String(false) //false  或者使用false.toString()
Boolean([])   //true
Object(3)   // new Number(3)
需要注意的时，除了null或undefined之外的任何值都具有toString()方法，这个方法的执行结果通常和String()方法的返回结果一致
同样需要注意的时，如果视图把null或undefined转换为对象，则会像表3-2所描述的那样抛出一个类型错误。
Object()函数在这种情况下不会抛出异常：它仅简单地返回一个新创建的空对象
js中的某些运算符会做隐式的类型转换，有时用于类型转换。如果“+”运算符的一个操作数时字符串，它将会把另外一个操作数转换为字符串。
一元“+”运算符将其操作数转换位数字。同样，一元“！”运算符将其操作数转换为布尔值并取反。
x + ''  //等价于String(x)
+x      //等价于Number(x)   也可以写成x - 0
!!x     //等价于Boolean(x) 注意时双叹号
在计算机程序中数字的解析和格式化是非常普通的工作，js中提供了专门的函数和方法用来做更加精确的数字到字符串和字符串到数字
Number类定义的toString()方法可以接收表示转换基数的可选参数，如果不指定此参数，转换规则将是基于十进制的。同样，亦可以将数字转换
为其他进制数
var n = 17
binary_string = n.toString(2)  //10001
octal_string ='0' + n.toString(8)   //021
hex_string = '0x' + n.toString(16)  //0x11
当处理财务或科学数据的时候，在做数字到字符串的转换过程中，你期望自己控制输出中小数店位值和有效数字为主，或者
决定是否需要指数计数法。Number类型为这种数字到字符串的类型转换场景定义了三个方法。toFixed()更具小数点后的指定位数
将数字转换为字符串，它从不使用指数计数法。toExponential()使用指数计数法将数字转换为指数形式的字符串，其中小数点前只有意味，小数店后的位数
则由参数指定（也就是说有效数字位数比指定的位数要多一位），toPrecision()根据指定的有效数字将数字转换成字符串。如果有效数字的位数少于数字整数部分的位数
则转换成指数形式。我们注意到，所有三个方法都会适当地进行四舍五入或填充0
如果通过Number()转换函数传入一个字符串，他会试图将其转换为一i个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现妃法的尾随字符，
parseInt()函数和parseFloat()函数（他们是全局函数，不丛书与任何类的方法）更加灵活。parseInt()只解析整数，而parseFloat()则可以解析整数和浮点数。
如字符串前缀是“0x”或者“0X”,parseInt()将其解释为十六进制数字，parseInt()和parseFloat()都会跳过任意数量的前导空格，
尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将返回NaN
parseInt()可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2~36
parseInt('11', 2)   //3 (1*2 + 1)
parseInt("ff", 16)   //255 (15*16 + 15)
parseInt('zz', 36)   //1295 (35*36 + 35)
parseInt('077', 8)   //63 (7*8 + 7)
parseInt('077', 10)  //77 (7*10 + 7)
3.8.3对象转换为原始值
对象到布尔值的转换非常简单：所有的对象（包含数组和函数）都转换为true，对于包装对象亦是如此:new Boolean(false)是一个对象而不是原始值，它将转换为true
对象到字符串和对象到数字的转换是通过调用待转换回显的一个方法来完成的。一个麻烦的事实是，js对象有两个不同得方法来执行转换
并且接下来要讨论的一些特殊场景更加复杂。值得注意的是，这里提到的字符串和数字的转换规则只适用于本地对象。宿主对象（web浏览器定义的对象）根据各自的算法可以转换成字符串和数字。
所有的对象继承了两个转换方法，第一个是toString()他的作用是返回一个反映这个对象的字符串。默认的toString()方法并不会返回一个有趣的值
({x:1, y:2}).toString()   '[object Object]'
很多类定义了更多 特别办的toString()方法，例如，数组类（Array class）的toString()方法将每个数组元素转换为一个字符串，并在元素之间添加逗号后合并成结果字符串
函数类的toString()方法返回这个函数的实现定义的表示方式。实际上，这里的实现方式是通常将用户定义的函数转换为js源代码字符串
日期类（Date class） 定义的同String()方法返回了一个可读日期和时间字符串。RegExp类定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串
[1,2,3].toString()  //'1,2,3'
(function(x){f(x)}).toString()  //'function(x){\n f(x) \n}'
/\d+/g.toString()   //'/\\d+/g'
new Date(2010,0,1).toString()  //'Fri Jan 01 2010 00:00:00 GMT-0800(PST)'

另一个转换对象的函数是valueOf()。这个方法的认为并未详细定义：如果存在任意原始值，它就默认将对象转换为表示它的原始值
对象是符合值，对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单的返回对象本身，而不是返回原始值
。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valaueOf()方法只是简单返回对象本身。日期类定义
的valueOf()方法返回他的一个内部表示：1970年1月1日依赖的毫秒数
var d = new Date(2010, 0, 1)  
d.valueOf()
通过使用我们刚刚讲解过的toString()和valueOf()方法，就可以做到对象到字符串和对象到数字的转换了。但需要注意的是
再某些特殊的场景中，js执行了完全不同的对象到原始值的转换。
js中对象到字符串的转换经过了如下这些步骤：
1.如果对象具有toString()方法，则调用这个方法。如果返回一个原始值，js将这个值转换为字符串（如果本身不是字符串的话），并返回一个字符串结果
1.如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么js会调用vlaueOf()。如果存在这个方法，则js调用它。如果返回值是原始值，js将这个值转换为字符串，并返回这个字符串结果
3.否则，js无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常

在对象到数字的转换过程中，js做了同样的事情，只是他会首先尝试使用valueOf()方法：
1.如果对象具有valueOf()方法，后者返回一个原始值，则js将这个原始值转换为数字（如果需要的话）并返回这个数字
2.否则，如果对象具有toString()方法，后者返回一个原始值，则js将其转换并返回
3.否则，js抛出一个类型错误异常

对象转换为数字的细节解释了为什么空数组会被转换为数字0以继为什么具有单个元素的数组同样会转换成一个数字。数组继承了
默认的valueOf()方法。这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString()方法。空数组转换
成为空字符串，空字符串转换成为数字0.含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果时一样的。如果
数组只包含一个数字元素，这个数字转换为字符串，在转换回数字。

JS中的‘+’运算符可以进行数学假发和字符串连接操作。如果它的其中一个操作数时对象，则js将使用特殊的方法将对象转换
为原始值，而不是使用其他算术运算符的方法执行对象到数字的转换  ‘==’相等运算符于此类似。如果将对象和一个原始值
比较，则转换将会遵照对象到原始值的转换方式进行

‘+’ 和 ‘==’应用的对象到原始值的转换包含日期对象的一i中特殊情形，日期类式js语言核心中唯一的预先定义类型，它定义
了又意义的向字符串和数字类型的转换，对于所有非日期对象来说，对象到原始值的转换基本上是对象到数字的转换
（首先调用valueOf()）,日期对象则使用对象到字符串的转换模式，然而，这里的转换和上问讲述的并不完全一致：
通过valueOf或toString()返回的原始值将被直接使用，而不会被强制转换为数字或字符串。
和'==' 一样， ‘《’运算符以继其他关系运算符也会做对象到原始值的转换，但要出去日期对象的特殊情形：
任何对象都回首先调用valueOf()，然后调用toString()不管得到的原始值是否直接使用，它都不会进一步被转换为数字或字符串

"+", '==', '!='和关系运算符是唯一执行这种特殊的字符串串到原始值的转换防止的运算符。其他运算符到特定类型的转换都很明确
而且对日期对象来讲也没有特殊情况。例如‘-’（减号）运算符把它的两个操作数都转换为数字。

var now = new Date()
typeof(now + 1)  // string:  "+"将日期转换为字符串
typeof(now - 1)  // number:  "-"使用对象到数字的转换
now == now.toString() //true  隐式的和显示的字符串转换
now > (now - 1)  //true  '>' 将日期转换为数字

3.9变量声明
js程序中，使用一个变量之前应当先声明。变量是使用关键字var来声明的
var i;
var sum;
也额可以通过一个var关键字来声明多个变量
var i, sum;
如果未再var声明语句中给变量指定初始值，那么虽然声明了这个变量，但再给他存入一个值之前，他的初始值就是undefined.

尽管再全局作用域编写代码时可以不写var语句，但声明局部变量时必须使用var语句

3.10.1函数作用域和声明前提
再一些类似c语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量再声明他们的代码段之外时不可见的，我们成为块作用域
而js中没有快作用域，js取而代之的使用了函数作用域：变量再声明他们的函数体以继这个函数体嵌套的任意函数体内都是有定义的
js的这个特性被非正式地成为声明提前，基金js函数里声明的所有变量都被七天至函数体的顶部
声明提前，这部操作实在js引擎的‘预编译’时进行的，实在代码开始运行之前

当声明一个js全局变量时，实际上定义了全局对象的一个属性
当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过delete运算符删除
js全局变量时全局对象的属性，这是再ECMAScript规范中强制规定的。对于局部变量则没有如此规定，但我们可以想象的得到
局部变量当作跟函数调用相关的某个对象的属性
ECMAScript3规范称该对象为‘调用对象’，ECMAScript5规范称为'声明上下文对象'。
js可以允许使用this关键字来引用全局对象，却没有方法可以引用局部变量中存放的对象。这种存放局部变量的
对象的特有性质，是一种对我们不可见的内部实现。然而，这些局部变量对象存在的观念是非常重要的，

3.10.3作用域链
js是基于词法作用域的语言：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。全局变量再程序中始终都是有定义的
局部变量在声明它的函数体内以继其他所嵌套的函数内始终是有意义的。
如果将一个局部变量看作是自定义实现的对象的属性的话，那么可以换个角度来解读变量作用域。每一段js代码（全局代码或函数）
都有一个与之关联的作用域链。这个作用域链是一个对象列表或者联邦，这组对象定义了这段代码‘作用域中’的变量。
当js需要查找变量x的值的时候（这个过程称作‘变量解析’），他会从链中的第一个对象开始查找，如果这个对象有个名为x的属性，则会
直接使用这个属性的值，如果第一个对象中不存在名为x的属性，js会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，
则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误异常

在js的最顶层代码中（也就是不包含在任何函数顶一个的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上
有两个对象，一个是定义函数参数和局部变量的对象，第二个给是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解
对象链的常见规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，
并将这个对象添加值保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的链。对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，
内部函数又会重新定义一边。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别--在每次调用外部函数时，
内部函数的代码都是相同的，而且管理这段代码的作用域链也不相同。

算术表达式
* 乘
/ 除法
% 求余
+ 加法
- 减法

位运算符

位运算符可以对由数字表示的二进制数据进行更滴层次的按位运算。尽管他们并不是传统的数学运算，但这里也将其归类位算术运算符，
因为他们作用域数值类型的操作数并返回数字。这些运算符在js编程中并不常用 ，如果你对十进制整数的二进制表示并不熟悉的话，你可以
跳过本节内容。这里的4个运算符都是对操作数的每个位进行布尔运算。这里将操作数的每个位当作布尔值(1=true , 0=false),其他三个运算符用来进行左移位或右移位

位运算符要求它的操作数时整数，这些整数表示32位整型而不是64位浮点型。必要时，位运算符首先将操作数转换位数字，并将数字强制表示位32位整型，这个
这会忽略原格式中的小数部分和任何超过32位的二进制位。移位运算符要求右操作数在0~31之间。在将其操作数转换位无符号32位整数后，他们将舍弃地5位之后的二进制位，
一边生成一个位数正确的数字。需要注意的时，位运算符将NaN/Infinity和-Infinity都转换位0

按位与(&)
    位运算符&对它的整型操作数逐位执行布尔与操作。只有两个操作数中相应的位都是1，结果中的这一位才是1
    例如 0x1234 & 0x00ff = 0x0034
按位或(|)
    位运算符|对它的整型操作数逐位执行布尔或操作。如果其中一个操作数相应的位位1，或者两个操作数相应位都是1，那么结果中的这意味就是1
    例如 0x1234 | 0x00ff = 0x12ff
按位异或(^)
    位运算符^对它的整型操作数逐位执行布尔异或操作。疑惑时值第一个操作数位true或第二个操作数位true，但两者不能同时位true
    如果两个操作书中只有一个像一位位1（不能同时为1），那么结果中的这一位就是1
    例如 0xff00 ^ 0xf0f0 = 0x0ff0
按位非(~)
    运算符~时一元运算符，位于一个整型参数之前，他将操作数的所有位取反。根据js中待符号的整数的表示方法，对一个值使用~运算符相当于改变 它的符号并减一
    例如 ~0x0f = 0xfffffff0或-16
左移(<<)
    将第一个操作数的所有二进制位进行左移操作，意味的位数由第二个操作数指定，移动的尾数是0~31之间的一个整数。例如，在表达式a<<1中
    a的第一位变成了第二位，a的第二位编程了它的第三位，以此类推。新的第一位用0来补充，舍弃第32位。将一个值左移1位向东与它乘以2，左移两位相当于乘以4
    例如7<<2 = 28
带符号右移(>>)
    运算符>>将第一个操作数的所有位进行有一操作，移动的位数由第二个操作数指定，移动的位数时0~31之间的一个整数。右边溢出的位将自动忽略。填补在左边的位由
    源操作数的符号决定，一边保持结果的符号与源操作数一致。如果第一个操作数时整数，为以后用0填补最高位；如果第一个操作数时负的，为以后就用1填补高位
    将一个值右移一位，相当于用它除以2（忽略余数），右移两位相当于它除以4，以此类推，例如，7>>1=3  -7>>1 = -4
无符号右移(>>>)
    运算符>>>和运算符>>一样，只是左边的高位总是填补0，与原来的操作数符号无关，
    例如： -1>>4 = -1   但是-1>>>4 = 0x0ffffffff

in运算符
in运算符希望它的左操作数时一个字符串或可以转换位字符串，希望它的右操作数时一个对象。如果右侧的对象拥有一个名为做操作之的属性名，那么表达式返回true
var point = { x:1, y:1 }
'x' in point    //true：对象有一个名为x的属性
'z' in point    //false 对象中不存在名位'z'的属性
'toString' in point //true 对象继承了toString()方法

var data = [7, 8, 9];  key
'0' in data //true 数组包含元素0
1 in data   //true 数字转换位字符串
3 in data   //false没有索引为3的元素