Socket通信原理

什么是TCP/IP、UDP？
TCP/IP(Transmission Control Protocol/Internet Protocol) 即传输控制协议/网间协议，是一个工业
标准 的协议集，它是为广域网（WANs）设计的
UDP(User Data Protocol, 用户数据报协议) 是与TCP相对应的协议。它是属于TCP/IP协议族中的一种


用户进程    用户进程      用户进程   用户进程      应用层
  \            \           /      /
   \           TCP        /      UDP            运输层
    \            \       /      / 
   ICMP <---------->    IP     <-----> IGMP     网络层
                        |
    ARP <---------->  接口硬件  <-----> RARP     链路层
                        |
                       媒体
TCP/IP协议族包括运输层、网络层、链路层。。现在你知道TCP/IP与UDP的关系了吧

Socket在哪里呢？
在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然

用户进程    用户进程    用户进程    用户进程      应用层
     \         \         /          /
      \         |        |         /
        --------------------------
        |      Socket 抽象层      |
        --------------------------
        |    \         |       /
        |     TCP      |     UDP               运输层
        |      \       |    /
      ICMP <-------->  IP  <-----> IGMP        网络层
                       |     
      ARP <-------->硬件接口<-----> RARP        链路层
                       | 
                      媒体
原来socket在这里。
Socket是什么呢
socket是应用层与TCP/ip协议族通信的中间软件抽象层，它是一组接口。在设计模式中，socket其实就是一个门面模式
他把复杂的ICP/IP协议族隐藏在socket接口后面，对于用户来说，一组简单的接口就是全部，让socket去组织数据，
以符合指定的协议。
你会使用他们吗？

前人已经给我吗做了好多的事情，网络间的通信业就简单了许多，但毕竟我们还是由挺多工作要做的。以前听到socket
编程，觉得他是比较高深的编程知识，但是只要弄清socket编程的工作原理，神秘的面纱也就揭开了。
一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起连接
就可以讲话了。等交流结束，挂电话结束此次交谈，生活中的场景就解释了这个工作原理，也许TCP/IP协议族就是诞生
与生活中，这也说不定

                                      TCP服务端

                                      socket()
                                        |
       TCP客户端                       bind()
                                        |
       socket()                       listen()
          |                             |
          |                           accept()
          |                      阻塞直到有客户端连接              
          |           建立连接           |
       connect() <------------------->  |
          |           请求数据           |
    ->  write()  <----------------->  read() <--
    |     |                     处理请求 |      |
    |     |           回应数据           |      |
    |-  read()   <------------------  write() -|
          |           结束连接           |
        close()  ------------------>  read()
                                        |
                                      close()

先从服务器端说起，服务器端先初始化Socket，然后与端口绑定(bind),对端口进行监听(listen),调用accept
阻塞，等待客户端连接，在这时如果有个客户端初始化一个socket，然后连接服务器(connect)，如果连接成功
这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接受请求并处理请求，然后把回应数据
发送给客户端，客户端读取数据，最后关闭连接，一次交互结束

我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与
web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信?这些都得靠socket?那什么
socket？socket的类型有哪些?还有socket的基本函数,这些都是本文想介绍的。
1.网络中进程之间如何通信
2.Socket是什么
3.socket的基本操作
  3.1socket()函数
  3.2 bind函数
  3.3 listen()、connect()函数
  3.4 accept()函数
  3.5 read()  write()函数
  3.6 close() 函数
4.socket中TCP的三次握手建立连接详解
5.socket中TCP的四次握手释放连接详解
6.一个例子

1.网络中进程之间如何通信?

本地的进程通信(IPC)有很多方式，但可以总结为下面4类：
。消息传递（管道、FIFO、消息队列）
。同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
。共享内存（匿名和具名的）
。远程过程调用（solaris门和sun rpc）
但这些都不是本文的主题， 我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，
否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族
已经帮我妈解决这个问题，网络层的iphi 地址可以唯一标识网络中的主机，而传入层的协议+端口可以唯一标识主机
主机中的应用程序（进程）。这个利用三元组（ip地址，协议，端口）就可以标识网络中的进程了，网络中的进程通信
就可以利用这个标志与其他进程进行交互

使用TCP/IP协议的应用程序通常采用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI(已经被淘汰)
来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中的
进程通信是无处不在，这就是我为什么说 一切皆socket

2.什么是socket
上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux
基本哲学之一就是‘一切皆文件’都可以用  打开open -- 读写write/read  -- 关闭close 模式来操作。我的理解
就是socket就是该模式的一个实现，socket即使一种特殊的文件，一些socket函数就是对其进行操作（读写、打开
关闭），这些函数我们在后面进行介绍

socket中TCP的三次握手建立连接详解
我们知道tcp建立连接要进行三次握手，即交换三个分组。大致流程如下：
1.客户端向服务器端发送一个  SYN J
2.服务器向客户端响应一个 SYN K,并对SYN J进行确认ACK J+1
3.客户端在想服务器发一个确认 ACK  K+1
只有走完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？

客户                    服务器

socket                    Socket , bind, linten
connect(阻塞)  SYN J    (被动打开)
（主动打开）              |  Accept(阻塞)
                         |
      <---  SYN K, ACK J+1
      |
connect(返回) 
      |--------->ACK K+1 ------>
                              |
                            Accept(返回)

从图中可以看出，当客户端调用connect时，出发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态
服务器监听到连接请求，即接受到SYN J包，调用accept函数接收请求向客户端发送SYN K, ACK J+1,这时accept
进入阻塞状态;客户端接收到服务器端的SYN K,ACK J+1之后，这时connect返回，并对SYN K进行确认;服务器收到
ACK K+1时，accept返回，致辞三次握手完毕，建立连接

socket中TCP的四次握手释放连接详解
上面介绍了socket中TCP的三次握手建立过程，及其设计的socket函数。现在我们介绍socket中的四次握手释放连接
的过程

客户                服务器

close       
(主动关闭)
        FIN M 
                    (被动关闭)
                    Read返回0
        ACK M+1
        FIN N       close
                    (主动关闭)
      
        ACK N+1

图示过程如下

。某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M
.另一端接受到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程
因为FIN的棘手以为这应用进程在相应的连接上在也接受不到额外数据
一段时间之后，接受到文件结束符的有引用进程调用close关闭它的socket。这导致他的TCP也发送一个FIN N
接受到这个FIN 的源发送端TCP对它进行确认



